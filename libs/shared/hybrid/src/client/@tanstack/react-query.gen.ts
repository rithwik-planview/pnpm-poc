// This file is auto-generated by @hey-api/openapi-ts

import {
    type Options,
    bugsGet,
    bugsGetGrouped,
    bugsGetByIdentifier,
    bugsGetByIds,
    bugsGetCount,
    bugsGetRelations,
    bugsGetRelationsCount,
    bugsGetGroupedRelations,
    bugsGetAvatars,
    bugsGetRelationsAvatars,
    casesGet,
    casesGetGrouped,
    casesGetByIdentifier,
    casesGetByIds,
    casesGetCount,
    casesGetRelations,
    casesGetRelationsCount,
    casesGetGroupedRelations,
    casesGetAvatars,
    casesGetRelationsAvatars,
    issuesGet,
    issuesGetGrouped,
    issuesGetByIdentifier,
    issuesGetByIds,
    issuesGetCount,
    issuesGetRelations,
    issuesGetRelationsCount,
    issuesGetGroupedRelations,
    issuesGetAvatars,
    issuesGetRelationsAvatars,
    requestsGet,
    requestsGetGrouped,
    requestsGetByIdentifier,
    requestsGetByIds,
    requestsGetCount,
    requestsGetRelations,
    requestsGetRelationsCount,
    requestsGetGroupedRelations,
    requestsGetAvatars,
    requestsGetRelationsAvatars,
    risksGet,
    risksGetGrouped,
    risksGetByIdentifier,
    risksGetByIds,
    risksGetCount,
    risksGetRelations,
    risksGetRelationsCount,
    risksGetGroupedRelations,
    risksGetAvatars,
    risksGetRelationsAvatars,
    genericEntityGet,
    genericEntityGetGrouped,
    genericEntityGetByIdentifier,
    genericEntityGetByIds,
    genericEntityGetCount,
    genericEntityGetRelations,
    genericEntityGetRelationsCount,
    genericEntityGetGroupedRelations,
    genericEntityGetEntityPicklist,
    genericEntityGetSwimlanes,
    genericEntityGetAvatars,
    genericEntityGetRelationAvatars,
    genericEntityGetCustomPanelByIdentifier,
    genericEntityGetSwimlanesByRelationIdentifier,
    genericEntityGetAvailableEntities,
    metadataGetPicklist,
    metadataGetFields,
    metadataGetSystemSettings,
    metadataGetOrganizationSettings,
    metadataGetEntitiesDescription,
    metadataGetAvailableFields,
    metadataGetRelationViewerFields,
    portfoliosGet,
    portfoliosGetGrouped,
    portfoliosGetByIdentifier,
    portfoliosGetByIds,
    portfoliosGetCount,
    portfoliosGetRelations,
    portfoliosGetRelationsCount,
    portfoliosGetGroupedRelations,
    portfoliosGetAvatars,
    portfoliosGetRelationsAvatars,
    propertyCardLayoutGetPropertyCardLayout,
    propertyCardLayoutGetPropertyCardLayoutByEntityId,
    jobTitlesGetCount,
    jobTitlesGetRelationsCount,
    jobTitlesGet,
    jobTitlesGetGrouped,
    jobTitlesGetByIdentifier,
    jobTitlesGetByIds,
    jobTitlesGetRelations,
    jobTitlesGetGroupedRelations,
    membersGetAllMembers,
    profilesGetCount,
    profilesGet,
    profilesGetByIdentifier,
    profilesGetByIds,
    profilesGetUserProfiles,
    skillsGet,
    skillsGetGrouped,
    skillsGetByIdentifier,
    skillsGetByIds,
    skillsGetCount,
    skillsGetRelations,
    skillsGetRelationsCount,
    skillsGetGroupedRelations,
    userGroupsGet,
    userGroupsGetGrouped,
    userGroupsGetByIdentifier,
    userGroupsGetByIds,
    userGroupsGetCount,
    userGroupsGetRelations,
    userGroupsGetRelationsCount,
    userGroupsGetGroupedRelations,
    userGroupsGetAuthorizationGroups,
    userGroupsGetRelatedGroupsForUser,
    usersGet,
    usersGetGrouped,
    usersGetByIdentifier,
    usersGetByIds,
    usersGetCount,
    usersGetRelations,
    usersGetRelationsCount,
    usersGetGroupedRelations,
    ribbonActionsGetRibbonActions,
    ribbonActionsGetContextMenus,
    milestonesGet,
    milestonesGetGrouped,
    milestonesGetByIdentifier,
    milestonesGetByIds,
    milestonesGetCount,
    milestonesGetRelations,
    milestonesGetRelationsCount,
    milestonesGetGroupedRelations,
    milestonesGetAvatars,
    milestonesGetRelationsAvatars,
    programsGet,
    programsGetGrouped,
    programsGetByIdentifier,
    programsGetByIds,
    programsGetCount,
    programsGetRelations,
    programsGetRelationsCount,
    programsGetGroupedRelations,
    programsGetAvatars,
    programsGetRelationsAvatars,
    projectsGet,
    projectsGetGrouped,
    projectsGetByIdentifier,
    projectsGetByIds,
    projectsGetCount,
    projectsGetRelations,
    projectsGetRelationsCount,
    projectsGetGroupedRelations,
    projectsGetAvatars,
    projectsGetRelationsAvatars,
    tasksGet,
    tasksGetGrouped,
    tasksGetByIdentifier,
    tasksGetByIds,
    tasksGetCount,
    tasksGetRelations,
    tasksGetRelationsCount,
    tasksGetGroupedRelations,
    tasksGetAvatars,
    tasksGetRelationsAvatars,
    dataWarehouseEntityGetCount,
    dataWarehouseEntityGetByIds,
    dataWarehouseEntityGetIds,
    configurationGetConfiguration,
    configurationUpdateConfiguration,
    storageConnectionsTestAzureBlobConnection,
    triggerExportTriggerExport,
    planviewAdminVerifyConnect,
    planviewAdminGetUsers,
    planviewAdminGet,
    planviewAdminRegister,
    planviewTokenServiceGetPtsTokenForCoPilot,
    planviewTokenServiceGetPtsTokenInternal,
    sentimentAnalysisServiceCalculateSentiment,
    whiteboardPtsTokenForWhiteboard,
    workloadGetWorkloadResources,
    workloadGetWorkloadProjects,
    workloadGetWorkloadTasks,
    publicisGetReportableWorkItemsPerUser,
    publicisGetReportableTasksByIds,
    publicisGetReportableTasksByIds2,
    publicisGetAssignmentsPerUsers,
    publicisGetUsersWorkingHours,
    publicisGetGroupMembershipLinks,
    publicisGetResourceProjects,
} from '../sdk.gen';
import {
    queryOptions,
    infiniteQueryOptions,
    type InfiniteData,
    type DefaultError,
    type UseMutationOptions,
} from '@tanstack/react-query';
import type {
    BugsGetData,
    BugsGetResponse,
    BugsGetGroupedData,
    BugsGetGroupedResponse,
    BugsGetByIdentifierData,
    BugsGetByIdentifierResponse,
    BugsGetByIdsData,
    BugsGetByIdsResponse,
    BugsGetCountData,
    BugsGetCountResponse,
    BugsGetRelationsData,
    BugsGetRelationsResponse,
    BugsGetRelationsCountData,
    BugsGetRelationsCountResponse,
    BugsGetGroupedRelationsData,
    BugsGetGroupedRelationsResponse,
    BugsGetAvatarsData,
    BugsGetAvatarsResponse,
    BugsGetRelationsAvatarsData,
    BugsGetRelationsAvatarsResponse,
    CasesGetData,
    CasesGetResponse,
    CasesGetGroupedData,
    CasesGetGroupedResponse,
    CasesGetByIdentifierData,
    CasesGetByIdentifierResponse,
    CasesGetByIdsData,
    CasesGetByIdsResponse,
    CasesGetCountData,
    CasesGetCountResponse,
    CasesGetRelationsData,
    CasesGetRelationsResponse,
    CasesGetRelationsCountData,
    CasesGetRelationsCountResponse,
    CasesGetGroupedRelationsData,
    CasesGetGroupedRelationsResponse,
    CasesGetAvatarsData,
    CasesGetAvatarsResponse,
    CasesGetRelationsAvatarsData,
    CasesGetRelationsAvatarsResponse,
    IssuesGetData,
    IssuesGetResponse,
    IssuesGetGroupedData,
    IssuesGetGroupedResponse,
    IssuesGetByIdentifierData,
    IssuesGetByIdentifierResponse,
    IssuesGetByIdsData,
    IssuesGetByIdsResponse,
    IssuesGetCountData,
    IssuesGetCountResponse,
    IssuesGetRelationsData,
    IssuesGetRelationsResponse,
    IssuesGetRelationsCountData,
    IssuesGetRelationsCountResponse,
    IssuesGetGroupedRelationsData,
    IssuesGetGroupedRelationsResponse,
    IssuesGetAvatarsData,
    IssuesGetAvatarsResponse,
    IssuesGetRelationsAvatarsData,
    IssuesGetRelationsAvatarsResponse,
    RequestsGetData,
    RequestsGetResponse,
    RequestsGetGroupedData,
    RequestsGetGroupedResponse,
    RequestsGetByIdentifierData,
    RequestsGetByIdentifierResponse,
    RequestsGetByIdsData,
    RequestsGetByIdsResponse,
    RequestsGetCountData,
    RequestsGetCountResponse,
    RequestsGetRelationsData,
    RequestsGetRelationsResponse,
    RequestsGetRelationsCountData,
    RequestsGetRelationsCountResponse,
    RequestsGetGroupedRelationsData,
    RequestsGetGroupedRelationsResponse,
    RequestsGetAvatarsData,
    RequestsGetAvatarsResponse,
    RequestsGetRelationsAvatarsData,
    RequestsGetRelationsAvatarsResponse,
    RisksGetData,
    RisksGetResponse,
    RisksGetGroupedData,
    RisksGetGroupedResponse,
    RisksGetByIdentifierData,
    RisksGetByIdentifierResponse,
    RisksGetByIdsData,
    RisksGetByIdsResponse,
    RisksGetCountData,
    RisksGetCountResponse,
    RisksGetRelationsData,
    RisksGetRelationsResponse,
    RisksGetRelationsCountData,
    RisksGetRelationsCountResponse,
    RisksGetGroupedRelationsData,
    RisksGetGroupedRelationsResponse,
    RisksGetAvatarsData,
    RisksGetAvatarsResponse,
    RisksGetRelationsAvatarsData,
    RisksGetRelationsAvatarsResponse,
    GenericEntityGetData,
    GenericEntityGetResponse,
    GenericEntityGetGroupedData,
    GenericEntityGetGroupedResponse,
    GenericEntityGetByIdentifierData,
    GenericEntityGetByIdentifierResponse,
    GenericEntityGetByIdsData,
    GenericEntityGetByIdsResponse,
    GenericEntityGetCountData,
    GenericEntityGetCountResponse,
    GenericEntityGetRelationsData,
    GenericEntityGetRelationsResponse,
    GenericEntityGetRelationsCountData,
    GenericEntityGetRelationsCountResponse,
    GenericEntityGetGroupedRelationsData,
    GenericEntityGetGroupedRelationsResponse,
    GenericEntityGetEntityPicklistData,
    GenericEntityGetSwimlanesData,
    GenericEntityGetSwimlanesResponse,
    GenericEntityGetAvatarsData,
    GenericEntityGetAvatarsResponse,
    GenericEntityGetRelationAvatarsData,
    GenericEntityGetRelationAvatarsResponse,
    GenericEntityGetCustomPanelByIdentifierData,
    GenericEntityGetSwimlanesByRelationIdentifierData,
    GenericEntityGetSwimlanesByRelationIdentifierResponse,
    GenericEntityGetAvailableEntitiesData,
    GenericEntityGetAvailableEntitiesResponse,
    MetadataGetPicklistData,
    MetadataGetPicklistResponse,
    MetadataGetFieldsData,
    MetadataGetFieldsResponse,
    MetadataGetSystemSettingsData,
    MetadataGetOrganizationSettingsData,
    MetadataGetEntitiesDescriptionData,
    MetadataGetEntitiesDescriptionResponse,
    MetadataGetAvailableFieldsData,
    MetadataGetAvailableFieldsResponse,
    MetadataGetRelationViewerFieldsData,
    MetadataGetRelationViewerFieldsResponse,
    PortfoliosGetData,
    PortfoliosGetResponse,
    PortfoliosGetGroupedData,
    PortfoliosGetGroupedResponse,
    PortfoliosGetByIdentifierData,
    PortfoliosGetByIdentifierResponse,
    PortfoliosGetByIdsData,
    PortfoliosGetByIdsResponse,
    PortfoliosGetCountData,
    PortfoliosGetCountResponse,
    PortfoliosGetRelationsData,
    PortfoliosGetRelationsResponse,
    PortfoliosGetRelationsCountData,
    PortfoliosGetRelationsCountResponse,
    PortfoliosGetGroupedRelationsData,
    PortfoliosGetGroupedRelationsResponse,
    PortfoliosGetAvatarsData,
    PortfoliosGetAvatarsResponse,
    PortfoliosGetRelationsAvatarsData,
    PortfoliosGetRelationsAvatarsResponse,
    PropertyCardLayoutGetPropertyCardLayoutData,
    PropertyCardLayoutGetPropertyCardLayoutByEntityIdData,
    JobTitlesGetCountData,
    JobTitlesGetCountResponse,
    JobTitlesGetRelationsCountData,
    JobTitlesGetRelationsCountResponse,
    JobTitlesGetData,
    JobTitlesGetResponse,
    JobTitlesGetGroupedData,
    JobTitlesGetGroupedResponse,
    JobTitlesGetByIdentifierData,
    JobTitlesGetByIdentifierResponse,
    JobTitlesGetByIdsData,
    JobTitlesGetByIdsResponse,
    JobTitlesGetRelationsData,
    JobTitlesGetRelationsResponse,
    JobTitlesGetGroupedRelationsData,
    JobTitlesGetGroupedRelationsResponse,
    MembersGetAllMembersData,
    MembersGetAllMembersResponse,
    ProfilesGetCountData,
    ProfilesGetCountResponse,
    ProfilesGetData,
    ProfilesGetResponse,
    ProfilesGetByIdentifierData,
    ProfilesGetByIdentifierResponse,
    ProfilesGetByIdsData,
    ProfilesGetByIdsResponse,
    ProfilesGetUserProfilesData,
    SkillsGetData,
    SkillsGetResponse,
    SkillsGetGroupedData,
    SkillsGetGroupedResponse,
    SkillsGetByIdentifierData,
    SkillsGetByIdentifierResponse,
    SkillsGetByIdsData,
    SkillsGetByIdsResponse,
    SkillsGetCountData,
    SkillsGetCountResponse,
    SkillsGetRelationsData,
    SkillsGetRelationsResponse,
    SkillsGetRelationsCountData,
    SkillsGetRelationsCountResponse,
    SkillsGetGroupedRelationsData,
    SkillsGetGroupedRelationsResponse,
    UserGroupsGetData,
    UserGroupsGetResponse,
    UserGroupsGetGroupedData,
    UserGroupsGetGroupedResponse,
    UserGroupsGetByIdentifierData,
    UserGroupsGetByIdentifierResponse,
    UserGroupsGetByIdsData,
    UserGroupsGetByIdsResponse,
    UserGroupsGetCountData,
    UserGroupsGetCountResponse,
    UserGroupsGetRelationsData,
    UserGroupsGetRelationsResponse,
    UserGroupsGetRelationsCountData,
    UserGroupsGetRelationsCountResponse,
    UserGroupsGetGroupedRelationsData,
    UserGroupsGetGroupedRelationsResponse,
    UserGroupsGetAuthorizationGroupsData,
    UserGroupsGetRelatedGroupsForUserData,
    UserGroupsGetRelatedGroupsForUserResponse,
    UsersGetData,
    UsersGetResponse,
    UsersGetGroupedData,
    UsersGetGroupedResponse,
    UsersGetByIdentifierData,
    UsersGetByIdentifierResponse,
    UsersGetByIdsData,
    UsersGetByIdsResponse,
    UsersGetCountData,
    UsersGetCountResponse,
    UsersGetRelationsData,
    UsersGetRelationsResponse,
    UsersGetRelationsCountData,
    UsersGetRelationsCountResponse,
    UsersGetGroupedRelationsData,
    UsersGetGroupedRelationsResponse,
    RibbonActionsGetRibbonActionsData,
    RibbonActionsGetRibbonActionsResponse,
    RibbonActionsGetContextMenusData,
    RibbonActionsGetContextMenusResponse,
    MilestonesGetData,
    MilestonesGetResponse,
    MilestonesGetGroupedData,
    MilestonesGetGroupedResponse,
    MilestonesGetByIdentifierData,
    MilestonesGetByIdentifierResponse,
    MilestonesGetByIdsData,
    MilestonesGetByIdsResponse,
    MilestonesGetCountData,
    MilestonesGetCountResponse,
    MilestonesGetRelationsData,
    MilestonesGetRelationsResponse,
    MilestonesGetRelationsCountData,
    MilestonesGetRelationsCountResponse,
    MilestonesGetGroupedRelationsData,
    MilestonesGetGroupedRelationsResponse,
    MilestonesGetAvatarsData,
    MilestonesGetAvatarsResponse,
    MilestonesGetRelationsAvatarsData,
    MilestonesGetRelationsAvatarsResponse,
    ProgramsGetData,
    ProgramsGetResponse,
    ProgramsGetGroupedData,
    ProgramsGetGroupedResponse,
    ProgramsGetByIdentifierData,
    ProgramsGetByIdentifierResponse,
    ProgramsGetByIdsData,
    ProgramsGetByIdsResponse,
    ProgramsGetCountData,
    ProgramsGetCountResponse,
    ProgramsGetRelationsData,
    ProgramsGetRelationsResponse,
    ProgramsGetRelationsCountData,
    ProgramsGetRelationsCountResponse,
    ProgramsGetGroupedRelationsData,
    ProgramsGetGroupedRelationsResponse,
    ProgramsGetAvatarsData,
    ProgramsGetAvatarsResponse,
    ProgramsGetRelationsAvatarsData,
    ProgramsGetRelationsAvatarsResponse,
    ProjectsGetData,
    ProjectsGetResponse,
    ProjectsGetGroupedData,
    ProjectsGetGroupedResponse,
    ProjectsGetByIdentifierData,
    ProjectsGetByIdentifierResponse,
    ProjectsGetByIdsData,
    ProjectsGetByIdsResponse,
    ProjectsGetCountData,
    ProjectsGetCountResponse,
    ProjectsGetRelationsData,
    ProjectsGetRelationsResponse,
    ProjectsGetRelationsCountData,
    ProjectsGetRelationsCountResponse,
    ProjectsGetGroupedRelationsData,
    ProjectsGetGroupedRelationsResponse,
    ProjectsGetAvatarsData,
    ProjectsGetAvatarsResponse,
    ProjectsGetRelationsAvatarsData,
    ProjectsGetRelationsAvatarsResponse,
    TasksGetData,
    TasksGetResponse,
    TasksGetGroupedData,
    TasksGetGroupedResponse,
    TasksGetByIdentifierData,
    TasksGetByIdentifierResponse,
    TasksGetByIdsData,
    TasksGetByIdsResponse,
    TasksGetCountData,
    TasksGetCountResponse,
    TasksGetRelationsData,
    TasksGetRelationsResponse,
    TasksGetRelationsCountData,
    TasksGetRelationsCountResponse,
    TasksGetGroupedRelationsData,
    TasksGetGroupedRelationsResponse,
    TasksGetAvatarsData,
    TasksGetAvatarsResponse,
    TasksGetRelationsAvatarsData,
    TasksGetRelationsAvatarsResponse,
    DataWarehouseEntityGetCountData,
    DataWarehouseEntityGetCountResponse,
    DataWarehouseEntityGetByIdsData,
    DataWarehouseEntityGetByIdsResponse,
    DataWarehouseEntityGetIdsData,
    DataWarehouseEntityGetIdsResponse,
    ConfigurationGetConfigurationData,
    ConfigurationGetConfigurationResponse,
    ConfigurationUpdateConfigurationData,
    StorageConnectionsTestAzureBlobConnectionData,
    StorageConnectionsTestAzureBlobConnectionResponse,
    TriggerExportTriggerExportData,
    PlanviewAdminVerifyConnectData,
    PlanviewAdminGetUsersData,
    PlanviewAdminGetData,
    PlanviewAdminRegisterData,
    PlanviewTokenServiceGetPtsTokenForCoPilotData,
    PlanviewTokenServiceGetPtsTokenInternalData,
    SentimentAnalysisServiceCalculateSentimentData,
    SentimentAnalysisServiceCalculateSentimentResponse,
    WhiteboardPtsTokenForWhiteboardData,
    WorkloadGetWorkloadResourcesData,
    WorkloadGetWorkloadResourcesResponse,
    WorkloadGetWorkloadProjectsData,
    WorkloadGetWorkloadProjectsResponse,
    WorkloadGetWorkloadTasksData,
    WorkloadGetWorkloadTasksResponse,
    PublicisGetReportableWorkItemsPerUserData,
    PublicisGetReportableWorkItemsPerUserResponse,
    PublicisGetReportableTasksByIdsData,
    PublicisGetReportableTasksByIdsResponse,
    PublicisGetReportableTasksByIds2Data,
    PublicisGetReportableTasksByIds2Response,
    PublicisGetAssignmentsPerUsersData,
    PublicisGetAssignmentsPerUsersResponse,
    PublicisGetUsersWorkingHoursData,
    PublicisGetUsersWorkingHoursResponse,
    PublicisGetGroupMembershipLinksData,
    PublicisGetGroupMembershipLinksResponse,
    PublicisGetResourceProjectsData,
    PublicisGetResourceProjectsResponse,
} from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    },
];

const createQueryKey = <TOptions extends Options>(
    id: string,
    options?: TOptions,
    infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
    const params: QueryKey<TOptions>[0] = {
        _id: id,
        baseURL: (options?.client ?? _heyApiClient).getConfig().baseURL,
    } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const bugsGetQueryKey = (options: Options<BugsGetData>) =>
    createQueryKey('bugsGet', options);

/**
 * Returns a list of Bugs.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const bugsGetOptions = (options: Options<BugsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetQueryKey(options),
    });
};

const createInfiniteParams = <
    K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
    queryKey: QueryKey<Options>,
    page: K,
) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...(queryKey[0].body as any),
            ...(page.body as any),
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers,
        };
    }
    if (page.path) {
        params.path = {
            ...(queryKey[0].path as any),
            ...(page.path as any),
        };
    }
    if (page.query) {
        params.query = {
            ...(queryKey[0].query as any),
            ...(page.query as any),
        };
    }
    return params as unknown as typeof page;
};

export const bugsGetInfiniteQueryKey = (
    options: Options<BugsGetData>,
): QueryKey<Options<BugsGetData>> => createQueryKey('bugsGet', options, true);

/**
 * Returns a list of Bugs.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const bugsGetInfiniteOptions = (options: Options<BugsGetData>) => {
    return infiniteQueryOptions<
        BugsGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<BugsGetResponse>,
        QueryKey<Options<BugsGetData>>,
        number | Pick<QueryKey<Options<BugsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<BugsGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await bugsGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: bugsGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Bugs.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const bugsGetMutation = (
    options?: Partial<Options<BugsGetData>>,
): UseMutationOptions<BugsGetResponse, AxiosError<DefaultError>, Options<BugsGetData>> => {
    const mutationOptions: UseMutationOptions<
        BugsGetResponse,
        AxiosError<DefaultError>,
        Options<BugsGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetGroupedQueryKey = (options: Options<BugsGetGroupedData>) =>
    createQueryKey('bugsGetGrouped', options);

/**
 * Returns a grouped list of Bugs.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const bugsGetGroupedOptions = (options: Options<BugsGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetGroupedQueryKey(options),
    });
};

export const bugsGetGroupedInfiniteQueryKey = (
    options: Options<BugsGetGroupedData>,
): QueryKey<Options<BugsGetGroupedData>> => createQueryKey('bugsGetGrouped', options, true);

/**
 * Returns a grouped list of Bugs.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const bugsGetGroupedInfiniteOptions = (options: Options<BugsGetGroupedData>) => {
    return infiniteQueryOptions<
        BugsGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<BugsGetGroupedResponse>,
        QueryKey<Options<BugsGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<BugsGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<BugsGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await bugsGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: bugsGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Bugs.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const bugsGetGroupedMutation = (
    options?: Partial<Options<BugsGetGroupedData>>,
): UseMutationOptions<
    BugsGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<BugsGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<BugsGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetByIdentifierQueryKey = (options: Options<BugsGetByIdentifierData>) =>
    createQueryKey('bugsGetByIdentifier', options);

/**
 * Returns a Bug by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const bugsGetByIdentifierOptions = (options: Options<BugsGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Bug by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const bugsGetByIdentifierMutation = (
    options?: Partial<Options<BugsGetByIdentifierData>>,
): UseMutationOptions<
    BugsGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<BugsGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<BugsGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetByIdsQueryKey = (options: Options<BugsGetByIdsData>) =>
    createQueryKey('bugsGetByIds', options);

/**
 * Returns a list of Bugs by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const bugsGetByIdsOptions = (options: Options<BugsGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetByIdsQueryKey(options),
    });
};

export const bugsGetByIdsInfiniteQueryKey = (
    options: Options<BugsGetByIdsData>,
): QueryKey<Options<BugsGetByIdsData>> => createQueryKey('bugsGetByIds', options, true);

/**
 * Returns a list of Bugs by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const bugsGetByIdsInfiniteOptions = (options: Options<BugsGetByIdsData>) => {
    return infiniteQueryOptions<
        BugsGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<BugsGetByIdsResponse>,
        QueryKey<Options<BugsGetByIdsData>>,
        number | Pick<QueryKey<Options<BugsGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<BugsGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await bugsGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: bugsGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Bugs by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const bugsGetByIdsMutation = (
    options?: Partial<Options<BugsGetByIdsData>>,
): UseMutationOptions<
    BugsGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<BugsGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<BugsGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetCountQueryKey = (options: Options<BugsGetCountData>) =>
    createQueryKey('bugsGetCount', options);

/**
 * Returns the number of Bugs.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetCountOptions = (options: Options<BugsGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Bugs.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetCountMutation = (
    options?: Partial<Options<BugsGetCountData>>,
): UseMutationOptions<
    BugsGetCountResponse,
    AxiosError<DefaultError>,
    Options<BugsGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetCountResponse,
        AxiosError<DefaultError>,
        Options<BugsGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetRelationsQueryKey = (options: Options<BugsGetRelationsData>) =>
    createQueryKey('bugsGetRelations', options);

/**
 * Returns a list of items related to a Bug.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const bugsGetRelationsOptions = (options: Options<BugsGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetRelationsQueryKey(options),
    });
};

export const bugsGetRelationsInfiniteQueryKey = (
    options: Options<BugsGetRelationsData>,
): QueryKey<Options<BugsGetRelationsData>> => createQueryKey('bugsGetRelations', options, true);

/**
 * Returns a list of items related to a Bug.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const bugsGetRelationsInfiniteOptions = (options: Options<BugsGetRelationsData>) => {
    return infiniteQueryOptions<
        BugsGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<BugsGetRelationsResponse>,
        QueryKey<Options<BugsGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<BugsGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<BugsGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await bugsGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: bugsGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Bug.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const bugsGetRelationsMutation = (
    options?: Partial<Options<BugsGetRelationsData>>,
): UseMutationOptions<
    BugsGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<BugsGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<BugsGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetRelationsCountQueryKey = (options: Options<BugsGetRelationsCountData>) =>
    createQueryKey('bugsGetRelationsCount', options);

/**
 * Returns the number of items related to a Bug.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetRelationsCountOptions = (options: Options<BugsGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Bug.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetRelationsCountMutation = (
    options?: Partial<Options<BugsGetRelationsCountData>>,
): UseMutationOptions<
    BugsGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<BugsGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<BugsGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetGroupedRelationsQueryKey = (options: Options<BugsGetGroupedRelationsData>) =>
    createQueryKey('bugsGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Bug.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const bugsGetGroupedRelationsOptions = (options: Options<BugsGetGroupedRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetGroupedRelationsQueryKey(options),
    });
};

export const bugsGetGroupedRelationsInfiniteQueryKey = (
    options: Options<BugsGetGroupedRelationsData>,
): QueryKey<Options<BugsGetGroupedRelationsData>> =>
    createQueryKey('bugsGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Bug.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const bugsGetGroupedRelationsInfiniteOptions = (
    options: Options<BugsGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        BugsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<BugsGetGroupedRelationsResponse>,
        QueryKey<Options<BugsGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<BugsGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<BugsGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await bugsGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: bugsGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Bug.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const bugsGetGroupedRelationsMutation = (
    options?: Partial<Options<BugsGetGroupedRelationsData>>,
): UseMutationOptions<
    BugsGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<BugsGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<BugsGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetAvatarsQueryKey = (options: Options<BugsGetAvatarsData>) =>
    createQueryKey('bugsGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetAvatarsOptions = (options: Options<BugsGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Bug",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetAvatarsMutation = (
    options?: Partial<Options<BugsGetAvatarsData>>,
): UseMutationOptions<
    BugsGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<BugsGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<BugsGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const bugsGetRelationsAvatarsQueryKey = (options: Options<BugsGetRelationsAvatarsData>) =>
    createQueryKey('bugsGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetRelationsAvatarsOptions = (options: Options<BugsGetRelationsAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bugsGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: bugsGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const bugsGetRelationsAvatarsMutation = (
    options?: Partial<Options<BugsGetRelationsAvatarsData>>,
): UseMutationOptions<
    BugsGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<BugsGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        BugsGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<BugsGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await bugsGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetQueryKey = (options: Options<CasesGetData>) =>
    createQueryKey('casesGet', options);

/**
 * Returns a list of Cases.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetOptions = (options: Options<CasesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetQueryKey(options),
    });
};

export const casesGetInfiniteQueryKey = (
    options: Options<CasesGetData>,
): QueryKey<Options<CasesGetData>> => createQueryKey('casesGet', options, true);

/**
 * Returns a list of Cases.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetInfiniteOptions = (options: Options<CasesGetData>) => {
    return infiniteQueryOptions<
        CasesGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<CasesGetResponse>,
        QueryKey<Options<CasesGetData>>,
        number | Pick<QueryKey<Options<CasesGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<CasesGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await casesGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: casesGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Cases.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetMutation = (
    options?: Partial<Options<CasesGetData>>,
): UseMutationOptions<CasesGetResponse, AxiosError<DefaultError>, Options<CasesGetData>> => {
    const mutationOptions: UseMutationOptions<
        CasesGetResponse,
        AxiosError<DefaultError>,
        Options<CasesGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetGroupedQueryKey = (options: Options<CasesGetGroupedData>) =>
    createQueryKey('casesGetGrouped', options);

/**
 * Returns a grouped list of Cases.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const casesGetGroupedOptions = (options: Options<CasesGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetGroupedQueryKey(options),
    });
};

export const casesGetGroupedInfiniteQueryKey = (
    options: Options<CasesGetGroupedData>,
): QueryKey<Options<CasesGetGroupedData>> => createQueryKey('casesGetGrouped', options, true);

/**
 * Returns a grouped list of Cases.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const casesGetGroupedInfiniteOptions = (options: Options<CasesGetGroupedData>) => {
    return infiniteQueryOptions<
        CasesGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<CasesGetGroupedResponse>,
        QueryKey<Options<CasesGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<CasesGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<CasesGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await casesGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: casesGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Cases.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const casesGetGroupedMutation = (
    options?: Partial<Options<CasesGetGroupedData>>,
): UseMutationOptions<
    CasesGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<CasesGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<CasesGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetByIdentifierQueryKey = (options: Options<CasesGetByIdentifierData>) =>
    createQueryKey('casesGetByIdentifier', options);

/**
 * Returns a Case by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetByIdentifierOptions = (options: Options<CasesGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Case by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetByIdentifierMutation = (
    options?: Partial<Options<CasesGetByIdentifierData>>,
): UseMutationOptions<
    CasesGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<CasesGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<CasesGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetByIdsQueryKey = (options: Options<CasesGetByIdsData>) =>
    createQueryKey('casesGetByIds', options);

/**
 * Returns a list of Cases by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const casesGetByIdsOptions = (options: Options<CasesGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetByIdsQueryKey(options),
    });
};

export const casesGetByIdsInfiniteQueryKey = (
    options: Options<CasesGetByIdsData>,
): QueryKey<Options<CasesGetByIdsData>> => createQueryKey('casesGetByIds', options, true);

/**
 * Returns a list of Cases by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const casesGetByIdsInfiniteOptions = (options: Options<CasesGetByIdsData>) => {
    return infiniteQueryOptions<
        CasesGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<CasesGetByIdsResponse>,
        QueryKey<Options<CasesGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<CasesGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<CasesGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await casesGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: casesGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Cases by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const casesGetByIdsMutation = (
    options?: Partial<Options<CasesGetByIdsData>>,
): UseMutationOptions<
    CasesGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<CasesGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<CasesGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetCountQueryKey = (options: Options<CasesGetCountData>) =>
    createQueryKey('casesGetCount', options);

/**
 * Returns the number of Cases.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetCountOptions = (options: Options<CasesGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Cases.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetCountMutation = (
    options?: Partial<Options<CasesGetCountData>>,
): UseMutationOptions<
    CasesGetCountResponse,
    AxiosError<DefaultError>,
    Options<CasesGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetCountResponse,
        AxiosError<DefaultError>,
        Options<CasesGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetRelationsQueryKey = (options: Options<CasesGetRelationsData>) =>
    createQueryKey('casesGetRelations', options);

/**
 * Returns a list of items related to a Case.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetRelationsOptions = (options: Options<CasesGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetRelationsQueryKey(options),
    });
};

export const casesGetRelationsInfiniteQueryKey = (
    options: Options<CasesGetRelationsData>,
): QueryKey<Options<CasesGetRelationsData>> => createQueryKey('casesGetRelations', options, true);

/**
 * Returns a list of items related to a Case.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetRelationsInfiniteOptions = (options: Options<CasesGetRelationsData>) => {
    return infiniteQueryOptions<
        CasesGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<CasesGetRelationsResponse>,
        QueryKey<Options<CasesGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<CasesGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<CasesGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await casesGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: casesGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Case.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const casesGetRelationsMutation = (
    options?: Partial<Options<CasesGetRelationsData>>,
): UseMutationOptions<
    CasesGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<CasesGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<CasesGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetRelationsCountQueryKey = (options: Options<CasesGetRelationsCountData>) =>
    createQueryKey('casesGetRelationsCount', options);

/**
 * Returns the number of items related to a Case.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetRelationsCountOptions = (options: Options<CasesGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Case.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetRelationsCountMutation = (
    options?: Partial<Options<CasesGetRelationsCountData>>,
): UseMutationOptions<
    CasesGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<CasesGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<CasesGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetGroupedRelationsQueryKey = (options: Options<CasesGetGroupedRelationsData>) =>
    createQueryKey('casesGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Case.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const casesGetGroupedRelationsOptions = (options: Options<CasesGetGroupedRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetGroupedRelationsQueryKey(options),
    });
};

export const casesGetGroupedRelationsInfiniteQueryKey = (
    options: Options<CasesGetGroupedRelationsData>,
): QueryKey<Options<CasesGetGroupedRelationsData>> =>
    createQueryKey('casesGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Case.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const casesGetGroupedRelationsInfiniteOptions = (
    options: Options<CasesGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        CasesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<CasesGetGroupedRelationsResponse>,
        QueryKey<Options<CasesGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<CasesGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<CasesGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await casesGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: casesGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Case.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const casesGetGroupedRelationsMutation = (
    options?: Partial<Options<CasesGetGroupedRelationsData>>,
): UseMutationOptions<
    CasesGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<CasesGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<CasesGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetAvatarsQueryKey = (options: Options<CasesGetAvatarsData>) =>
    createQueryKey('casesGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetAvatarsOptions = (options: Options<CasesGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Case",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetAvatarsMutation = (
    options?: Partial<Options<CasesGetAvatarsData>>,
): UseMutationOptions<
    CasesGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<CasesGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<CasesGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const casesGetRelationsAvatarsQueryKey = (options: Options<CasesGetRelationsAvatarsData>) =>
    createQueryKey('casesGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetRelationsAvatarsOptions = (options: Options<CasesGetRelationsAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await casesGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: casesGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const casesGetRelationsAvatarsMutation = (
    options?: Partial<Options<CasesGetRelationsAvatarsData>>,
): UseMutationOptions<
    CasesGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<CasesGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        CasesGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<CasesGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await casesGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetQueryKey = (options: Options<IssuesGetData>) =>
    createQueryKey('issuesGet', options);

/**
 * Returns a list of Issues.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const issuesGetOptions = (options: Options<IssuesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetQueryKey(options),
    });
};

export const issuesGetInfiniteQueryKey = (
    options: Options<IssuesGetData>,
): QueryKey<Options<IssuesGetData>> => createQueryKey('issuesGet', options, true);

/**
 * Returns a list of Issues.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const issuesGetInfiniteOptions = (options: Options<IssuesGetData>) => {
    return infiniteQueryOptions<
        IssuesGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<IssuesGetResponse>,
        QueryKey<Options<IssuesGetData>>,
        number | Pick<QueryKey<Options<IssuesGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<IssuesGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await issuesGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: issuesGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Issues.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const issuesGetMutation = (
    options?: Partial<Options<IssuesGetData>>,
): UseMutationOptions<IssuesGetResponse, AxiosError<DefaultError>, Options<IssuesGetData>> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetGroupedQueryKey = (options: Options<IssuesGetGroupedData>) =>
    createQueryKey('issuesGetGrouped', options);

/**
 * Returns a grouped list of Issues.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const issuesGetGroupedOptions = (options: Options<IssuesGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetGroupedQueryKey(options),
    });
};

export const issuesGetGroupedInfiniteQueryKey = (
    options: Options<IssuesGetGroupedData>,
): QueryKey<Options<IssuesGetGroupedData>> => createQueryKey('issuesGetGrouped', options, true);

/**
 * Returns a grouped list of Issues.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const issuesGetGroupedInfiniteOptions = (options: Options<IssuesGetGroupedData>) => {
    return infiniteQueryOptions<
        IssuesGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<IssuesGetGroupedResponse>,
        QueryKey<Options<IssuesGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<IssuesGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<IssuesGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await issuesGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: issuesGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Issues.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const issuesGetGroupedMutation = (
    options?: Partial<Options<IssuesGetGroupedData>>,
): UseMutationOptions<
    IssuesGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetByIdentifierQueryKey = (options: Options<IssuesGetByIdentifierData>) =>
    createQueryKey('issuesGetByIdentifier', options);

/**
 * Returns an Issue by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const issuesGetByIdentifierOptions = (options: Options<IssuesGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns an Issue by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const issuesGetByIdentifierMutation = (
    options?: Partial<Options<IssuesGetByIdentifierData>>,
): UseMutationOptions<
    IssuesGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetByIdsQueryKey = (options: Options<IssuesGetByIdsData>) =>
    createQueryKey('issuesGetByIds', options);

/**
 * Returns a list of Issues by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const issuesGetByIdsOptions = (options: Options<IssuesGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetByIdsQueryKey(options),
    });
};

export const issuesGetByIdsInfiniteQueryKey = (
    options: Options<IssuesGetByIdsData>,
): QueryKey<Options<IssuesGetByIdsData>> => createQueryKey('issuesGetByIds', options, true);

/**
 * Returns a list of Issues by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const issuesGetByIdsInfiniteOptions = (options: Options<IssuesGetByIdsData>) => {
    return infiniteQueryOptions<
        IssuesGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<IssuesGetByIdsResponse>,
        QueryKey<Options<IssuesGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<IssuesGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<IssuesGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await issuesGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: issuesGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Issues by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const issuesGetByIdsMutation = (
    options?: Partial<Options<IssuesGetByIdsData>>,
): UseMutationOptions<
    IssuesGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetCountQueryKey = (options: Options<IssuesGetCountData>) =>
    createQueryKey('issuesGetCount', options);

/**
 * Returns the number of Issues.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetCountOptions = (options: Options<IssuesGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Issues.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetCountMutation = (
    options?: Partial<Options<IssuesGetCountData>>,
): UseMutationOptions<
    IssuesGetCountResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetCountResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetRelationsQueryKey = (options: Options<IssuesGetRelationsData>) =>
    createQueryKey('issuesGetRelations', options);

/**
 * Returns a list of items related to an Issue.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const issuesGetRelationsOptions = (options: Options<IssuesGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetRelationsQueryKey(options),
    });
};

export const issuesGetRelationsInfiniteQueryKey = (
    options: Options<IssuesGetRelationsData>,
): QueryKey<Options<IssuesGetRelationsData>> => createQueryKey('issuesGetRelations', options, true);

/**
 * Returns a list of items related to an Issue.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const issuesGetRelationsInfiniteOptions = (options: Options<IssuesGetRelationsData>) => {
    return infiniteQueryOptions<
        IssuesGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<IssuesGetRelationsResponse>,
        QueryKey<Options<IssuesGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<IssuesGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<IssuesGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await issuesGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: issuesGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to an Issue.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const issuesGetRelationsMutation = (
    options?: Partial<Options<IssuesGetRelationsData>>,
): UseMutationOptions<
    IssuesGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetRelationsCountQueryKey = (options: Options<IssuesGetRelationsCountData>) =>
    createQueryKey('issuesGetRelationsCount', options);

/**
 * Returns the number of items related to an Issue.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetRelationsCountOptions = (options: Options<IssuesGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to an Issue.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetRelationsCountMutation = (
    options?: Partial<Options<IssuesGetRelationsCountData>>,
): UseMutationOptions<
    IssuesGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetGroupedRelationsQueryKey = (
    options: Options<IssuesGetGroupedRelationsData>,
) => createQueryKey('issuesGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to an Issue.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const issuesGetGroupedRelationsOptions = (
    options: Options<IssuesGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetGroupedRelationsQueryKey(options),
    });
};

export const issuesGetGroupedRelationsInfiniteQueryKey = (
    options: Options<IssuesGetGroupedRelationsData>,
): QueryKey<Options<IssuesGetGroupedRelationsData>> =>
    createQueryKey('issuesGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to an Issue.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const issuesGetGroupedRelationsInfiniteOptions = (
    options: Options<IssuesGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        IssuesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<IssuesGetGroupedRelationsResponse>,
        QueryKey<Options<IssuesGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<IssuesGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<IssuesGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await issuesGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: issuesGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to an Issue.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const issuesGetGroupedRelationsMutation = (
    options?: Partial<Options<IssuesGetGroupedRelationsData>>,
): UseMutationOptions<
    IssuesGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetAvatarsQueryKey = (options: Options<IssuesGetAvatarsData>) =>
    createQueryKey('issuesGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetAvatarsOptions = (options: Options<IssuesGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Issue",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetAvatarsMutation = (
    options?: Partial<Options<IssuesGetAvatarsData>>,
): UseMutationOptions<
    IssuesGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const issuesGetRelationsAvatarsQueryKey = (
    options: Options<IssuesGetRelationsAvatarsData>,
) => createQueryKey('issuesGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetRelationsAvatarsOptions = (
    options: Options<IssuesGetRelationsAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await issuesGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: issuesGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const issuesGetRelationsAvatarsMutation = (
    options?: Partial<Options<IssuesGetRelationsAvatarsData>>,
): UseMutationOptions<
    IssuesGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<IssuesGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        IssuesGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<IssuesGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await issuesGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetQueryKey = (options: Options<RequestsGetData>) =>
    createQueryKey('requestsGet', options);

/**
 * Returns a list of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "itemType": "Numeric",
 * "value": 10
 * },
 * {
 * "itemType": "Numeric",
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const requestsGetOptions = (options: Options<RequestsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetQueryKey(options),
    });
};

export const requestsGetInfiniteQueryKey = (
    options: Options<RequestsGetData>,
): QueryKey<Options<RequestsGetData>> => createQueryKey('requestsGet', options, true);

/**
 * Returns a list of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "itemType": "Numeric",
 * "value": 10
 * },
 * {
 * "itemType": "Numeric",
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const requestsGetInfiniteOptions = (options: Options<RequestsGetData>) => {
    return infiniteQueryOptions<
        RequestsGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<RequestsGetResponse>,
        QueryKey<Options<RequestsGetData>>,
        number | Pick<QueryKey<Options<RequestsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RequestsGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await requestsGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: requestsGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "itemType": "Numeric",
 * "value": 10
 * },
 * {
 * "itemType": "Numeric",
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const requestsGetMutation = (
    options?: Partial<Options<RequestsGetData>>,
): UseMutationOptions<RequestsGetResponse, AxiosError<DefaultError>, Options<RequestsGetData>> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetGroupedQueryKey = (options: Options<RequestsGetGroupedData>) =>
    createQueryKey('requestsGetGrouped', options);

/**
 * Returns a grouped list of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const requestsGetGroupedOptions = (options: Options<RequestsGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetGroupedQueryKey(options),
    });
};

export const requestsGetGroupedInfiniteQueryKey = (
    options: Options<RequestsGetGroupedData>,
): QueryKey<Options<RequestsGetGroupedData>> => createQueryKey('requestsGetGrouped', options, true);

/**
 * Returns a grouped list of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const requestsGetGroupedInfiniteOptions = (options: Options<RequestsGetGroupedData>) => {
    return infiniteQueryOptions<
        RequestsGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<RequestsGetGroupedResponse>,
        QueryKey<Options<RequestsGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<RequestsGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RequestsGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await requestsGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: requestsGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const requestsGetGroupedMutation = (
    options?: Partial<Options<RequestsGetGroupedData>>,
): UseMutationOptions<
    RequestsGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetByIdentifierQueryKey = (options: Options<RequestsGetByIdentifierData>) =>
    createQueryKey('requestsGetByIdentifier', options);

/**
 * Returns a Request (EnhancementRequest) by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const requestsGetByIdentifierOptions = (options: Options<RequestsGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Request (EnhancementRequest) by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const requestsGetByIdentifierMutation = (
    options?: Partial<Options<RequestsGetByIdentifierData>>,
): UseMutationOptions<
    RequestsGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetByIdsQueryKey = (options: Options<RequestsGetByIdsData>) =>
    createQueryKey('requestsGetByIds', options);

/**
 * Returns a list of Requests (EnhancementRequest) by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const requestsGetByIdsOptions = (options: Options<RequestsGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetByIdsQueryKey(options),
    });
};

export const requestsGetByIdsInfiniteQueryKey = (
    options: Options<RequestsGetByIdsData>,
): QueryKey<Options<RequestsGetByIdsData>> => createQueryKey('requestsGetByIds', options, true);

/**
 * Returns a list of Requests (EnhancementRequest) by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const requestsGetByIdsInfiniteOptions = (options: Options<RequestsGetByIdsData>) => {
    return infiniteQueryOptions<
        RequestsGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<RequestsGetByIdsResponse>,
        QueryKey<Options<RequestsGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<RequestsGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RequestsGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await requestsGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: requestsGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Requests (EnhancementRequest) by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const requestsGetByIdsMutation = (
    options?: Partial<Options<RequestsGetByIdsData>>,
): UseMutationOptions<
    RequestsGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetCountQueryKey = (options: Options<RequestsGetCountData>) =>
    createQueryKey('requestsGetCount', options);

/**
 * Returns the number of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetCountOptions = (options: Options<RequestsGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Requests (EnhancementRequest).
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetCountMutation = (
    options?: Partial<Options<RequestsGetCountData>>,
): UseMutationOptions<
    RequestsGetCountResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetCountResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetRelationsQueryKey = (options: Options<RequestsGetRelationsData>) =>
    createQueryKey('requestsGetRelations', options);

/**
 * Returns a list of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const requestsGetRelationsOptions = (options: Options<RequestsGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetRelationsQueryKey(options),
    });
};

export const requestsGetRelationsInfiniteQueryKey = (
    options: Options<RequestsGetRelationsData>,
): QueryKey<Options<RequestsGetRelationsData>> =>
    createQueryKey('requestsGetRelations', options, true);

/**
 * Returns a list of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const requestsGetRelationsInfiniteOptions = (options: Options<RequestsGetRelationsData>) => {
    return infiniteQueryOptions<
        RequestsGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<RequestsGetRelationsResponse>,
        QueryKey<Options<RequestsGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<RequestsGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RequestsGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await requestsGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: requestsGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const requestsGetRelationsMutation = (
    options?: Partial<Options<RequestsGetRelationsData>>,
): UseMutationOptions<
    RequestsGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetRelationsCountQueryKey = (
    options: Options<RequestsGetRelationsCountData>,
) => createQueryKey('requestsGetRelationsCount', options);

/**
 * Returns the number of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetRelationsCountOptions = (
    options: Options<RequestsGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetRelationsCountMutation = (
    options?: Partial<Options<RequestsGetRelationsCountData>>,
): UseMutationOptions<
    RequestsGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetGroupedRelationsQueryKey = (
    options: Options<RequestsGetGroupedRelationsData>,
) => createQueryKey('requestsGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const requestsGetGroupedRelationsOptions = (
    options: Options<RequestsGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetGroupedRelationsQueryKey(options),
    });
};

export const requestsGetGroupedRelationsInfiniteQueryKey = (
    options: Options<RequestsGetGroupedRelationsData>,
): QueryKey<Options<RequestsGetGroupedRelationsData>> =>
    createQueryKey('requestsGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const requestsGetGroupedRelationsInfiniteOptions = (
    options: Options<RequestsGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        RequestsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<RequestsGetGroupedRelationsResponse>,
        QueryKey<Options<RequestsGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<RequestsGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RequestsGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await requestsGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: requestsGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Request (EnhancementRequest).
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const requestsGetGroupedRelationsMutation = (
    options?: Partial<Options<RequestsGetGroupedRelationsData>>,
): UseMutationOptions<
    RequestsGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetAvatarsQueryKey = (options: Options<RequestsGetAvatarsData>) =>
    createQueryKey('requestsGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetAvatarsOptions = (options: Options<RequestsGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "EnhancementRequest",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetAvatarsMutation = (
    options?: Partial<Options<RequestsGetAvatarsData>>,
): UseMutationOptions<
    RequestsGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const requestsGetRelationsAvatarsQueryKey = (
    options: Options<RequestsGetRelationsAvatarsData>,
) => createQueryKey('requestsGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetRelationsAvatarsOptions = (
    options: Options<RequestsGetRelationsAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestsGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: requestsGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const requestsGetRelationsAvatarsMutation = (
    options?: Partial<Options<RequestsGetRelationsAvatarsData>>,
): UseMutationOptions<
    RequestsGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<RequestsGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        RequestsGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<RequestsGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await requestsGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetQueryKey = (options: Options<RisksGetData>) =>
    createQueryKey('risksGet', options);

/**
 * Returns a list of Risks.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const risksGetOptions = (options: Options<RisksGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetQueryKey(options),
    });
};

export const risksGetInfiniteQueryKey = (
    options: Options<RisksGetData>,
): QueryKey<Options<RisksGetData>> => createQueryKey('risksGet', options, true);

/**
 * Returns a list of Risks.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const risksGetInfiniteOptions = (options: Options<RisksGetData>) => {
    return infiniteQueryOptions<
        RisksGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<RisksGetResponse>,
        QueryKey<Options<RisksGetData>>,
        number | Pick<QueryKey<Options<RisksGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RisksGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await risksGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: risksGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Risks.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const risksGetMutation = (
    options?: Partial<Options<RisksGetData>>,
): UseMutationOptions<RisksGetResponse, AxiosError<DefaultError>, Options<RisksGetData>> => {
    const mutationOptions: UseMutationOptions<
        RisksGetResponse,
        AxiosError<DefaultError>,
        Options<RisksGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetGroupedQueryKey = (options: Options<RisksGetGroupedData>) =>
    createQueryKey('risksGetGrouped', options);

/**
 * Returns a grouped list of Risks.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const risksGetGroupedOptions = (options: Options<RisksGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetGroupedQueryKey(options),
    });
};

export const risksGetGroupedInfiniteQueryKey = (
    options: Options<RisksGetGroupedData>,
): QueryKey<Options<RisksGetGroupedData>> => createQueryKey('risksGetGrouped', options, true);

/**
 * Returns a grouped list of Risks.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const risksGetGroupedInfiniteOptions = (options: Options<RisksGetGroupedData>) => {
    return infiniteQueryOptions<
        RisksGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<RisksGetGroupedResponse>,
        QueryKey<Options<RisksGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<RisksGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RisksGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await risksGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: risksGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Risks.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const risksGetGroupedMutation = (
    options?: Partial<Options<RisksGetGroupedData>>,
): UseMutationOptions<
    RisksGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<RisksGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<RisksGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetByIdentifierQueryKey = (options: Options<RisksGetByIdentifierData>) =>
    createQueryKey('risksGetByIdentifier', options);

/**
 * Returns a Risk by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const risksGetByIdentifierOptions = (options: Options<RisksGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Risk by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const risksGetByIdentifierMutation = (
    options?: Partial<Options<RisksGetByIdentifierData>>,
): UseMutationOptions<
    RisksGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<RisksGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<RisksGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetByIdsQueryKey = (options: Options<RisksGetByIdsData>) =>
    createQueryKey('risksGetByIds', options);

/**
 * Returns a list of Risks by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const risksGetByIdsOptions = (options: Options<RisksGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetByIdsQueryKey(options),
    });
};

export const risksGetByIdsInfiniteQueryKey = (
    options: Options<RisksGetByIdsData>,
): QueryKey<Options<RisksGetByIdsData>> => createQueryKey('risksGetByIds', options, true);

/**
 * Returns a list of Risks by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const risksGetByIdsInfiniteOptions = (options: Options<RisksGetByIdsData>) => {
    return infiniteQueryOptions<
        RisksGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<RisksGetByIdsResponse>,
        QueryKey<Options<RisksGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<RisksGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RisksGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await risksGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: risksGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Risks by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const risksGetByIdsMutation = (
    options?: Partial<Options<RisksGetByIdsData>>,
): UseMutationOptions<
    RisksGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<RisksGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<RisksGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetCountQueryKey = (options: Options<RisksGetCountData>) =>
    createQueryKey('risksGetCount', options);

/**
 * Returns the number of Risks.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetCountOptions = (options: Options<RisksGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Risks.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetCountMutation = (
    options?: Partial<Options<RisksGetCountData>>,
): UseMutationOptions<
    RisksGetCountResponse,
    AxiosError<DefaultError>,
    Options<RisksGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetCountResponse,
        AxiosError<DefaultError>,
        Options<RisksGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetRelationsQueryKey = (options: Options<RisksGetRelationsData>) =>
    createQueryKey('risksGetRelations', options);

/**
 * Returns a list of items related to a Risk.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const risksGetRelationsOptions = (options: Options<RisksGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetRelationsQueryKey(options),
    });
};

export const risksGetRelationsInfiniteQueryKey = (
    options: Options<RisksGetRelationsData>,
): QueryKey<Options<RisksGetRelationsData>> => createQueryKey('risksGetRelations', options, true);

/**
 * Returns a list of items related to a Risk.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const risksGetRelationsInfiniteOptions = (options: Options<RisksGetRelationsData>) => {
    return infiniteQueryOptions<
        RisksGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<RisksGetRelationsResponse>,
        QueryKey<Options<RisksGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<RisksGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RisksGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await risksGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: risksGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Risk.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const risksGetRelationsMutation = (
    options?: Partial<Options<RisksGetRelationsData>>,
): UseMutationOptions<
    RisksGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<RisksGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<RisksGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetRelationsCountQueryKey = (options: Options<RisksGetRelationsCountData>) =>
    createQueryKey('risksGetRelationsCount', options);

/**
 * Returns the number of items related to a Risk.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetRelationsCountOptions = (options: Options<RisksGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Risk.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetRelationsCountMutation = (
    options?: Partial<Options<RisksGetRelationsCountData>>,
): UseMutationOptions<
    RisksGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<RisksGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<RisksGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetGroupedRelationsQueryKey = (options: Options<RisksGetGroupedRelationsData>) =>
    createQueryKey('risksGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Risk.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const risksGetGroupedRelationsOptions = (options: Options<RisksGetGroupedRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetGroupedRelationsQueryKey(options),
    });
};

export const risksGetGroupedRelationsInfiniteQueryKey = (
    options: Options<RisksGetGroupedRelationsData>,
): QueryKey<Options<RisksGetGroupedRelationsData>> =>
    createQueryKey('risksGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Risk.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const risksGetGroupedRelationsInfiniteOptions = (
    options: Options<RisksGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        RisksGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<RisksGetGroupedRelationsResponse>,
        QueryKey<Options<RisksGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<RisksGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<RisksGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await risksGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: risksGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Risk.
 * Sample request:
 *
 * {
 * "fields": [
 * "title",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "title",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const risksGetGroupedRelationsMutation = (
    options?: Partial<Options<RisksGetGroupedRelationsData>>,
): UseMutationOptions<
    RisksGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<RisksGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<RisksGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetAvatarsQueryKey = (options: Options<RisksGetAvatarsData>) =>
    createQueryKey('risksGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Onwer",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetAvatarsOptions = (options: Options<RisksGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Onwer",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetAvatarsMutation = (
    options?: Partial<Options<RisksGetAvatarsData>>,
): UseMutationOptions<
    RisksGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<RisksGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<RisksGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const risksGetRelationsAvatarsQueryKey = (options: Options<RisksGetRelationsAvatarsData>) =>
    createQueryKey('risksGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetRelationsAvatarsOptions = (options: Options<RisksGetRelationsAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await risksGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: risksGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "case",
 * "fieldName": "title"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const risksGetRelationsAvatarsMutation = (
    options?: Partial<Options<RisksGetRelationsAvatarsData>>,
): UseMutationOptions<
    RisksGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<RisksGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        RisksGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<RisksGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await risksGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetQueryKey = (options: Options<GenericEntityGetData>) =>
    createQueryKey('genericEntityGet', options);

/**
 * Returns a list of entities.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "entityType"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "Name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "ABC"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const genericEntityGetOptions = (options: Options<GenericEntityGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetQueryKey(options),
    });
};

export const genericEntityGetInfiniteQueryKey = (
    options: Options<GenericEntityGetData>,
): QueryKey<Options<GenericEntityGetData>> => createQueryKey('genericEntityGet', options, true);

/**
 * Returns a list of entities.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "entityType"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "Name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "ABC"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const genericEntityGetInfiniteOptions = (options: Options<GenericEntityGetData>) => {
    return infiniteQueryOptions<
        GenericEntityGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetResponse>,
        QueryKey<Options<GenericEntityGetData>>,
        | number
        | Pick<QueryKey<Options<GenericEntityGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of entities.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "entityType"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "Name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "ABC"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const genericEntityGetMutation = (
    options?: Partial<Options<GenericEntityGetData>>,
): UseMutationOptions<
    GenericEntityGetResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetGroupedQueryKey = (options: Options<GenericEntityGetGroupedData>) =>
    createQueryKey('genericEntityGetGrouped', options);

/**
 * Returns a grouped list of entities.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "entityType"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "entityType",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetGroupedOptions = (options: Options<GenericEntityGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetGroupedQueryKey(options),
    });
};

export const genericEntityGetGroupedInfiniteQueryKey = (
    options: Options<GenericEntityGetGroupedData>,
): QueryKey<Options<GenericEntityGetGroupedData>> =>
    createQueryKey('genericEntityGetGrouped', options, true);

/**
 * Returns a grouped list of entities.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "entityType"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "entityType",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetGroupedInfiniteOptions = (
    options: Options<GenericEntityGetGroupedData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetGroupedResponse>,
        QueryKey<Options<GenericEntityGetGroupedData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetGroupedData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of entities.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "entityType"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "entityType",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetGroupedMutation = (
    options?: Partial<Options<GenericEntityGetGroupedData>>,
): UseMutationOptions<
    GenericEntityGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetByIdentifierQueryKey = (
    options: Options<GenericEntityGetByIdentifierData>,
) => createQueryKey('genericEntityGetByIdentifier', options);

/**
 * Returns an entity by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "fieldName1",
 * "fieldName2",
 * ],
 * "relations": [
 * "relationName
 * ],
 * "excludePermissions": true
 * }
 */
export const genericEntityGetByIdentifierOptions = (
    options: Options<GenericEntityGetByIdentifierData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns an entity by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "fieldName1",
 * "fieldName2",
 * ],
 * "relations": [
 * "relationName
 * ],
 * "excludePermissions": true
 * }
 */
export const genericEntityGetByIdentifierMutation = (
    options?: Partial<Options<GenericEntityGetByIdentifierData>>,
): UseMutationOptions<
    GenericEntityGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetByIdsQueryKey = (options: Options<GenericEntityGetByIdsData>) =>
    createQueryKey('genericEntityGetByIds', options);

/**
 * Returns a list of entities by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const genericEntityGetByIdsOptions = (options: Options<GenericEntityGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetByIdsQueryKey(options),
    });
};

export const genericEntityGetByIdsInfiniteQueryKey = (
    options: Options<GenericEntityGetByIdsData>,
): QueryKey<Options<GenericEntityGetByIdsData>> =>
    createQueryKey('genericEntityGetByIds', options, true);

/**
 * Returns a list of entities by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const genericEntityGetByIdsInfiniteOptions = (
    options: Options<GenericEntityGetByIdsData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetByIdsResponse>,
        QueryKey<Options<GenericEntityGetByIdsData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetByIdsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of entities by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const genericEntityGetByIdsMutation = (
    options?: Partial<Options<GenericEntityGetByIdsData>>,
): UseMutationOptions<
    GenericEntityGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetCountQueryKey = (options: Options<GenericEntityGetCountData>) =>
    createQueryKey('genericEntityGetCount', options);

/**
 * Returns the number of entities.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ]
 * }
 */
export const genericEntityGetCountOptions = (options: Options<GenericEntityGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetCountQueryKey(options),
    });
};

/**
 * Returns the number of entities.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ]
 * }
 */
export const genericEntityGetCountMutation = (
    options?: Partial<Options<GenericEntityGetCountData>>,
): UseMutationOptions<
    GenericEntityGetCountResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetCountResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetRelationsQueryKey = (
    options: Options<GenericEntityGetRelationsData>,
) => createQueryKey('genericEntityGetRelations', options);

/**
 * Returns a list of items related to the entity.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const genericEntityGetRelationsOptions = (
    options: Options<GenericEntityGetRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetRelationsQueryKey(options),
    });
};

export const genericEntityGetRelationsInfiniteQueryKey = (
    options: Options<GenericEntityGetRelationsData>,
): QueryKey<Options<GenericEntityGetRelationsData>> =>
    createQueryKey('genericEntityGetRelations', options, true);

/**
 * Returns a list of items related to the entity.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const genericEntityGetRelationsInfiniteOptions = (
    options: Options<GenericEntityGetRelationsData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetRelationsResponse>,
        QueryKey<Options<GenericEntityGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to the entity.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const genericEntityGetRelationsMutation = (
    options?: Partial<Options<GenericEntityGetRelationsData>>,
): UseMutationOptions<
    GenericEntityGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetRelationsCountQueryKey = (
    options: Options<GenericEntityGetRelationsCountData>,
) => createQueryKey('genericEntityGetRelationsCount', options);

/**
 * Returns the number of items related to the entity.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const genericEntityGetRelationsCountOptions = (
    options: Options<GenericEntityGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to the entity.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const genericEntityGetRelationsCountMutation = (
    options?: Partial<Options<GenericEntityGetRelationsCountData>>,
): UseMutationOptions<
    GenericEntityGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetGroupedRelationsQueryKey = (
    options: Options<GenericEntityGetGroupedRelationsData>,
) => createQueryKey('genericEntityGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to the entity.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetGroupedRelationsOptions = (
    options: Options<GenericEntityGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetGroupedRelationsQueryKey(options),
    });
};

export const genericEntityGetGroupedRelationsInfiniteQueryKey = (
    options: Options<GenericEntityGetGroupedRelationsData>,
): QueryKey<Options<GenericEntityGetGroupedRelationsData>> =>
    createQueryKey('genericEntityGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to the entity.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetGroupedRelationsInfiniteOptions = (
    options: Options<GenericEntityGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetGroupedRelationsResponse>,
        QueryKey<Options<GenericEntityGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to the entity.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetGroupedRelationsMutation = (
    options?: Partial<Options<GenericEntityGetGroupedRelationsData>>,
): UseMutationOptions<
    GenericEntityGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetEntityPicklistQueryKey = (
    options: Options<GenericEntityGetEntityPicklistData>,
) => createQueryKey('genericEntityGetEntityPicklist', options);

/**
 * Returns picklist options honoring dependent field value.
 */
export const genericEntityGetEntityPicklistOptions = (
    options: Options<GenericEntityGetEntityPicklistData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetEntityPicklist({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetEntityPicklistQueryKey(options),
    });
};

export const genericEntityGetSwimlanesQueryKey = (
    options: Options<GenericEntityGetSwimlanesData>,
) => createQueryKey('genericEntityGetSwimlanes', options);

/**
 * Returns distinct list of related items with global aggregate for group by field.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "entityType"
 * ],
 * "dataFilters": [],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "entityType",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetSwimlanesOptions = (
    options: Options<GenericEntityGetSwimlanesData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetSwimlanes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetSwimlanesQueryKey(options),
    });
};

export const genericEntityGetSwimlanesInfiniteQueryKey = (
    options: Options<GenericEntityGetSwimlanesData>,
): QueryKey<Options<GenericEntityGetSwimlanesData>> =>
    createQueryKey('genericEntityGetSwimlanes', options, true);

/**
 * Returns distinct list of related items with global aggregate for group by field.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "entityType"
 * ],
 * "dataFilters": [],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "entityType",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetSwimlanesInfiniteOptions = (
    options: Options<GenericEntityGetSwimlanesData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetSwimlanesResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetSwimlanesResponse>,
        QueryKey<Options<GenericEntityGetSwimlanesData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetSwimlanesData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetSwimlanesData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetSwimlanes({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetSwimlanesInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns distinct list of related items with global aggregate for group by field.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "entityType"
 * ],
 * "dataFilters": [],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "entityType",
 * "groupName": "Active"
 * }
 */
export const genericEntityGetSwimlanesMutation = (
    options?: Partial<Options<GenericEntityGetSwimlanesData>>,
): UseMutationOptions<
    GenericEntityGetSwimlanesResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetSwimlanesData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetSwimlanesResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetSwimlanesData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetSwimlanes({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetAvatarsQueryKey = (options: Options<GenericEntityGetAvatarsData>) =>
    createQueryKey('genericEntityGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "ProjectManager",
 * "dataFilters": []
 * }
 */
export const genericEntityGetAvatarsOptions = (options: Options<GenericEntityGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "ProjectManager",
 * "dataFilters": []
 * }
 */
export const genericEntityGetAvatarsMutation = (
    options?: Partial<Options<GenericEntityGetAvatarsData>>,
): UseMutationOptions<
    GenericEntityGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetRelationAvatarsQueryKey = (
    options: Options<GenericEntityGetRelationAvatarsData>,
) => createQueryKey('genericEntityGetRelationAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": []
 * }
 */
export const genericEntityGetRelationAvatarsOptions = (
    options: Options<GenericEntityGetRelationAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetRelationAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetRelationAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": []
 * }
 */
export const genericEntityGetRelationAvatarsMutation = (
    options?: Partial<Options<GenericEntityGetRelationAvatarsData>>,
): UseMutationOptions<
    GenericEntityGetRelationAvatarsResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetRelationAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetRelationAvatarsResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetRelationAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetRelationAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetCustomPanelByIdentifierQueryKey = (
    options: Options<GenericEntityGetCustomPanelByIdentifierData>,
) => createQueryKey('genericEntityGetCustomPanelByIdentifier', options);

/**
 * Retrieves list of custom panel associated with Entity
 */
export const genericEntityGetCustomPanelByIdentifierOptions = (
    options: Options<GenericEntityGetCustomPanelByIdentifierData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetCustomPanelByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetCustomPanelByIdentifierQueryKey(options),
    });
};

export const genericEntityGetSwimlanesByRelationIdentifierQueryKey = (
    options: Options<GenericEntityGetSwimlanesByRelationIdentifierData>,
) => createQueryKey('genericEntityGetSwimlanesByRelationIdentifier', options);

export const genericEntityGetSwimlanesByRelationIdentifierOptions = (
    options: Options<GenericEntityGetSwimlanesByRelationIdentifierData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetSwimlanesByRelationIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetSwimlanesByRelationIdentifierQueryKey(options),
    });
};

export const genericEntityGetSwimlanesByRelationIdentifierInfiniteQueryKey = (
    options: Options<GenericEntityGetSwimlanesByRelationIdentifierData>,
): QueryKey<Options<GenericEntityGetSwimlanesByRelationIdentifierData>> =>
    createQueryKey('genericEntityGetSwimlanesByRelationIdentifier', options, true);

export const genericEntityGetSwimlanesByRelationIdentifierInfiniteOptions = (
    options: Options<GenericEntityGetSwimlanesByRelationIdentifierData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetSwimlanesByRelationIdentifierResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetSwimlanesByRelationIdentifierResponse>,
        QueryKey<Options<GenericEntityGetSwimlanesByRelationIdentifierData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetSwimlanesByRelationIdentifierData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetSwimlanesByRelationIdentifierData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetSwimlanesByRelationIdentifier({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetSwimlanesByRelationIdentifierInfiniteQueryKey(options),
        },
    );
};

export const genericEntityGetSwimlanesByRelationIdentifierMutation = (
    options?: Partial<Options<GenericEntityGetSwimlanesByRelationIdentifierData>>,
): UseMutationOptions<
    GenericEntityGetSwimlanesByRelationIdentifierResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetSwimlanesByRelationIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetSwimlanesByRelationIdentifierResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetSwimlanesByRelationIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetSwimlanesByRelationIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const genericEntityGetAvailableEntitiesQueryKey = (
    options: Options<GenericEntityGetAvailableEntitiesData>,
) => createQueryKey('genericEntityGetAvailableEntities', options);

export const genericEntityGetAvailableEntitiesOptions = (
    options: Options<GenericEntityGetAvailableEntitiesData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genericEntityGetAvailableEntities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: genericEntityGetAvailableEntitiesQueryKey(options),
    });
};

export const genericEntityGetAvailableEntitiesInfiniteQueryKey = (
    options: Options<GenericEntityGetAvailableEntitiesData>,
): QueryKey<Options<GenericEntityGetAvailableEntitiesData>> =>
    createQueryKey('genericEntityGetAvailableEntities', options, true);

export const genericEntityGetAvailableEntitiesInfiniteOptions = (
    options: Options<GenericEntityGetAvailableEntitiesData>,
) => {
    return infiniteQueryOptions<
        GenericEntityGetAvailableEntitiesResponse,
        AxiosError<DefaultError>,
        InfiniteData<GenericEntityGetAvailableEntitiesResponse>,
        QueryKey<Options<GenericEntityGetAvailableEntitiesData>>,
        | number
        | Pick<
              QueryKey<Options<GenericEntityGetAvailableEntitiesData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GenericEntityGetAvailableEntitiesData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await genericEntityGetAvailableEntities({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: genericEntityGetAvailableEntitiesInfiniteQueryKey(options),
        },
    );
};

export const genericEntityGetAvailableEntitiesMutation = (
    options?: Partial<Options<GenericEntityGetAvailableEntitiesData>>,
): UseMutationOptions<
    GenericEntityGetAvailableEntitiesResponse,
    AxiosError<DefaultError>,
    Options<GenericEntityGetAvailableEntitiesData>
> => {
    const mutationOptions: UseMutationOptions<
        GenericEntityGetAvailableEntitiesResponse,
        AxiosError<DefaultError>,
        Options<GenericEntityGetAvailableEntitiesData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await genericEntityGetAvailableEntities({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const metadataGetPicklistQueryKey = (options: Options<MetadataGetPicklistData>) =>
    createQueryKey('metadataGetPicklist', options);

/**
 * Returns picklist options for specific entity type.
 * Sample request:
 *
 * {
 * "entityType": "Task",
 * "propertyNames": [
 * "State",
 * "Phase"
 * ]
 * }
 */
export const metadataGetPicklistOptions = (options: Options<MetadataGetPicklistData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetPicklist({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetPicklistQueryKey(options),
    });
};

/**
 * Returns picklist options for specific entity type.
 * Sample request:
 *
 * {
 * "entityType": "Task",
 * "propertyNames": [
 * "State",
 * "Phase"
 * ]
 * }
 */
export const metadataGetPicklistMutation = (
    options?: Partial<Options<MetadataGetPicklistData>>,
): UseMutationOptions<
    MetadataGetPicklistResponse,
    AxiosError<DefaultError>,
    Options<MetadataGetPicklistData>
> => {
    const mutationOptions: UseMutationOptions<
        MetadataGetPicklistResponse,
        AxiosError<DefaultError>,
        Options<MetadataGetPicklistData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await metadataGetPicklist({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const metadataGetFieldsQueryKey = (options: Options<MetadataGetFieldsData>) =>
    createQueryKey('metadataGetFields', options);

/**
 * Returns fields and relations details for specific entity.
 * Sample request:
 *
 * {
 * "entityType": "Task",
 * "propertyNames": [
 * "State",
 * "Phase"
 * ],
 * "relationNames": [
 * "RelatedRisks"
 * ],
 * "includeFields": true,
 * "includeRelations": true
 * }
 */
export const metadataGetFieldsOptions = (options: Options<MetadataGetFieldsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetFieldsQueryKey(options),
    });
};

/**
 * Returns fields and relations details for specific entity.
 * Sample request:
 *
 * {
 * "entityType": "Task",
 * "propertyNames": [
 * "State",
 * "Phase"
 * ],
 * "relationNames": [
 * "RelatedRisks"
 * ],
 * "includeFields": true,
 * "includeRelations": true
 * }
 */
export const metadataGetFieldsMutation = (
    options?: Partial<Options<MetadataGetFieldsData>>,
): UseMutationOptions<
    MetadataGetFieldsResponse,
    AxiosError<DefaultError>,
    Options<MetadataGetFieldsData>
> => {
    const mutationOptions: UseMutationOptions<
        MetadataGetFieldsResponse,
        AxiosError<DefaultError>,
        Options<MetadataGetFieldsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await metadataGetFields({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const metadataGetSystemSettingsQueryKey = (
    options?: Options<MetadataGetSystemSettingsData>,
) => createQueryKey('metadataGetSystemSettings', options);

/**
 * Returns basic system settings.
 */
export const metadataGetSystemSettingsOptions = (
    options?: Options<MetadataGetSystemSettingsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetSystemSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetSystemSettingsQueryKey(options),
    });
};

export const metadataGetOrganizationSettingsQueryKey = (
    options?: Options<MetadataGetOrganizationSettingsData>,
) => createQueryKey('metadataGetOrganizationSettings', options);

/**
 * Returns general organization settings.
 */
export const metadataGetOrganizationSettingsOptions = (
    options?: Options<MetadataGetOrganizationSettingsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetOrganizationSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetOrganizationSettingsQueryKey(options),
    });
};

export const metadataGetEntitiesDescriptionQueryKey = (
    options: Options<MetadataGetEntitiesDescriptionData>,
) => createQueryKey('metadataGetEntitiesDescription', options);

/**
 * Returns information about the entity types in your organization.
 */
export const metadataGetEntitiesDescriptionOptions = (
    options: Options<MetadataGetEntitiesDescriptionData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetEntitiesDescription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetEntitiesDescriptionQueryKey(options),
    });
};

/**
 * Returns information about the entity types in your organization.
 */
export const metadataGetEntitiesDescriptionMutation = (
    options?: Partial<Options<MetadataGetEntitiesDescriptionData>>,
): UseMutationOptions<
    MetadataGetEntitiesDescriptionResponse,
    AxiosError<DefaultError>,
    Options<MetadataGetEntitiesDescriptionData>
> => {
    const mutationOptions: UseMutationOptions<
        MetadataGetEntitiesDescriptionResponse,
        AxiosError<DefaultError>,
        Options<MetadataGetEntitiesDescriptionData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await metadataGetEntitiesDescription({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const metadataGetAvailableFieldsQueryKey = (
    options: Options<MetadataGetAvailableFieldsData>,
) => createQueryKey('metadataGetAvailableFields', options);

/**
 * Returns available fields for a specific entity and it's children.
 */
export const metadataGetAvailableFieldsOptions = (
    options: Options<MetadataGetAvailableFieldsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetAvailableFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetAvailableFieldsQueryKey(options),
    });
};

/**
 * Returns available fields for a specific entity and it's children.
 */
export const metadataGetAvailableFieldsMutation = (
    options?: Partial<Options<MetadataGetAvailableFieldsData>>,
): UseMutationOptions<
    MetadataGetAvailableFieldsResponse,
    AxiosError<DefaultError>,
    Options<MetadataGetAvailableFieldsData>
> => {
    const mutationOptions: UseMutationOptions<
        MetadataGetAvailableFieldsResponse,
        AxiosError<DefaultError>,
        Options<MetadataGetAvailableFieldsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await metadataGetAvailableFields({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const metadataGetRelationViewerFieldsQueryKey = (
    options: Options<MetadataGetRelationViewerFieldsData>,
) => createQueryKey('metadataGetRelationViewerFields', options);

/**
 * Returns available fields for a specific realtion.
 */
export const metadataGetRelationViewerFieldsOptions = (
    options: Options<MetadataGetRelationViewerFieldsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await metadataGetRelationViewerFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: metadataGetRelationViewerFieldsQueryKey(options),
    });
};

/**
 * Returns available fields for a specific realtion.
 */
export const metadataGetRelationViewerFieldsMutation = (
    options?: Partial<Options<MetadataGetRelationViewerFieldsData>>,
): UseMutationOptions<
    MetadataGetRelationViewerFieldsResponse,
    AxiosError<DefaultError>,
    Options<MetadataGetRelationViewerFieldsData>
> => {
    const mutationOptions: UseMutationOptions<
        MetadataGetRelationViewerFieldsResponse,
        AxiosError<DefaultError>,
        Options<MetadataGetRelationViewerFieldsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await metadataGetRelationViewerFields({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetQueryKey = (options: Options<PortfoliosGetData>) =>
    createQueryKey('portfoliosGet', options);

/**
 * Returns a list of Portfolios.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const portfoliosGetOptions = (options: Options<PortfoliosGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetQueryKey(options),
    });
};

export const portfoliosGetInfiniteQueryKey = (
    options: Options<PortfoliosGetData>,
): QueryKey<Options<PortfoliosGetData>> => createQueryKey('portfoliosGet', options, true);

/**
 * Returns a list of Portfolios.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const portfoliosGetInfiniteOptions = (options: Options<PortfoliosGetData>) => {
    return infiniteQueryOptions<
        PortfoliosGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<PortfoliosGetResponse>,
        QueryKey<Options<PortfoliosGetData>>,
        | number
        | Pick<QueryKey<Options<PortfoliosGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<PortfoliosGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await portfoliosGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: portfoliosGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Portfolios.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const portfoliosGetMutation = (
    options?: Partial<Options<PortfoliosGetData>>,
): UseMutationOptions<
    PortfoliosGetResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetGroupedQueryKey = (options: Options<PortfoliosGetGroupedData>) =>
    createQueryKey('portfoliosGetGrouped', options);

/**
 * Returns a grouped list of Portfolios.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "PortfolioState",
 * "groupName": "Active"
 * }
 */
export const portfoliosGetGroupedOptions = (options: Options<PortfoliosGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetGroupedQueryKey(options),
    });
};

export const portfoliosGetGroupedInfiniteQueryKey = (
    options: Options<PortfoliosGetGroupedData>,
): QueryKey<Options<PortfoliosGetGroupedData>> =>
    createQueryKey('portfoliosGetGrouped', options, true);

/**
 * Returns a grouped list of Portfolios.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "PortfolioState",
 * "groupName": "Active"
 * }
 */
export const portfoliosGetGroupedInfiniteOptions = (options: Options<PortfoliosGetGroupedData>) => {
    return infiniteQueryOptions<
        PortfoliosGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<PortfoliosGetGroupedResponse>,
        QueryKey<Options<PortfoliosGetGroupedData>>,
        | number
        | Pick<
              QueryKey<Options<PortfoliosGetGroupedData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<PortfoliosGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await portfoliosGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: portfoliosGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Portfolios.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "PortfolioState",
 * "groupName": "Active"
 * }
 */
export const portfoliosGetGroupedMutation = (
    options?: Partial<Options<PortfoliosGetGroupedData>>,
): UseMutationOptions<
    PortfoliosGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetByIdentifierQueryKey = (
    options: Options<PortfoliosGetByIdentifierData>,
) => createQueryKey('portfoliosGetByIdentifier', options);

/**
 * Returns a Portfolio by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "excludePermissions": true
 * }
 */
export const portfoliosGetByIdentifierOptions = (
    options: Options<PortfoliosGetByIdentifierData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Portfolio by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "excludePermissions": true
 * }
 */
export const portfoliosGetByIdentifierMutation = (
    options?: Partial<Options<PortfoliosGetByIdentifierData>>,
): UseMutationOptions<
    PortfoliosGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetByIdsQueryKey = (options: Options<PortfoliosGetByIdsData>) =>
    createQueryKey('portfoliosGetByIds', options);

/**
 * Returns a list of Portfolios by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const portfoliosGetByIdsOptions = (options: Options<PortfoliosGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetByIdsQueryKey(options),
    });
};

export const portfoliosGetByIdsInfiniteQueryKey = (
    options: Options<PortfoliosGetByIdsData>,
): QueryKey<Options<PortfoliosGetByIdsData>> => createQueryKey('portfoliosGetByIds', options, true);

/**
 * Returns a list of Portfolios by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const portfoliosGetByIdsInfiniteOptions = (options: Options<PortfoliosGetByIdsData>) => {
    return infiniteQueryOptions<
        PortfoliosGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<PortfoliosGetByIdsResponse>,
        QueryKey<Options<PortfoliosGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<PortfoliosGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<PortfoliosGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await portfoliosGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: portfoliosGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Portfolios by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "PortfolioState"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const portfoliosGetByIdsMutation = (
    options?: Partial<Options<PortfoliosGetByIdsData>>,
): UseMutationOptions<
    PortfoliosGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetCountQueryKey = (options: Options<PortfoliosGetCountData>) =>
    createQueryKey('portfoliosGetCount', options);

/**
 * Returns the number of Portfolios.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetCountOptions = (options: Options<PortfoliosGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Portfolios.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "InvestmentYear"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 2000
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetCountMutation = (
    options?: Partial<Options<PortfoliosGetCountData>>,
): UseMutationOptions<
    PortfoliosGetCountResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetCountResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetRelationsQueryKey = (options: Options<PortfoliosGetRelationsData>) =>
    createQueryKey('portfoliosGetRelations', options);

/**
 * Returns a list of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const portfoliosGetRelationsOptions = (options: Options<PortfoliosGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetRelationsQueryKey(options),
    });
};

export const portfoliosGetRelationsInfiniteQueryKey = (
    options: Options<PortfoliosGetRelationsData>,
): QueryKey<Options<PortfoliosGetRelationsData>> =>
    createQueryKey('portfoliosGetRelations', options, true);

/**
 * Returns a list of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const portfoliosGetRelationsInfiniteOptions = (
    options: Options<PortfoliosGetRelationsData>,
) => {
    return infiniteQueryOptions<
        PortfoliosGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<PortfoliosGetRelationsResponse>,
        QueryKey<Options<PortfoliosGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<PortfoliosGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<PortfoliosGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await portfoliosGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: portfoliosGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const portfoliosGetRelationsMutation = (
    options?: Partial<Options<PortfoliosGetRelationsData>>,
): UseMutationOptions<
    PortfoliosGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetRelationsCountQueryKey = (
    options: Options<PortfoliosGetRelationsCountData>,
) => createQueryKey('portfoliosGetRelationsCount', options);

/**
 * Returns the number of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetRelationsCountOptions = (
    options: Options<PortfoliosGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetRelationsCountMutation = (
    options?: Partial<Options<PortfoliosGetRelationsCountData>>,
): UseMutationOptions<
    PortfoliosGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetGroupedRelationsQueryKey = (
    options: Options<PortfoliosGetGroupedRelationsData>,
) => createQueryKey('portfoliosGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const portfoliosGetGroupedRelationsOptions = (
    options: Options<PortfoliosGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetGroupedRelationsQueryKey(options),
    });
};

export const portfoliosGetGroupedRelationsInfiniteQueryKey = (
    options: Options<PortfoliosGetGroupedRelationsData>,
): QueryKey<Options<PortfoliosGetGroupedRelationsData>> =>
    createQueryKey('portfoliosGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const portfoliosGetGroupedRelationsInfiniteOptions = (
    options: Options<PortfoliosGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        PortfoliosGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<PortfoliosGetGroupedRelationsResponse>,
        QueryKey<Options<PortfoliosGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<PortfoliosGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<PortfoliosGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await portfoliosGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: portfoliosGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Portfolio.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const portfoliosGetGroupedRelationsMutation = (
    options?: Partial<Options<PortfoliosGetGroupedRelationsData>>,
): UseMutationOptions<
    PortfoliosGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetAvatarsQueryKey = (options: Options<PortfoliosGetAvatarsData>) =>
    createQueryKey('portfoliosGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetAvatarsOptions = (options: Options<PortfoliosGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetAvatarsMutation = (
    options?: Partial<Options<PortfoliosGetAvatarsData>>,
): UseMutationOptions<
    PortfoliosGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const portfoliosGetRelationsAvatarsQueryKey = (
    options: Options<PortfoliosGetRelationsAvatarsData>,
) => createQueryKey('portfoliosGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetRelationsAvatarsOptions = (
    options: Options<PortfoliosGetRelationsAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await portfoliosGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: portfoliosGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Portfolio",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const portfoliosGetRelationsAvatarsMutation = (
    options?: Partial<Options<PortfoliosGetRelationsAvatarsData>>,
): UseMutationOptions<
    PortfoliosGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<PortfoliosGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        PortfoliosGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<PortfoliosGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await portfoliosGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const propertyCardLayoutGetPropertyCardLayoutQueryKey = (
    options: Options<PropertyCardLayoutGetPropertyCardLayoutData>,
) => createQueryKey('propertyCardLayoutGetPropertyCardLayout', options);

/**
 * Returns a Property Card layout for the specific entity type.
 */
export const propertyCardLayoutGetPropertyCardLayoutOptions = (
    options: Options<PropertyCardLayoutGetPropertyCardLayoutData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await propertyCardLayoutGetPropertyCardLayout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: propertyCardLayoutGetPropertyCardLayoutQueryKey(options),
    });
};

export const propertyCardLayoutGetPropertyCardLayoutByEntityIdQueryKey = (
    options: Options<PropertyCardLayoutGetPropertyCardLayoutByEntityIdData>,
) => createQueryKey('propertyCardLayoutGetPropertyCardLayoutByEntityId', options);

/**
 * Returns a Property Card layout for the specific internal id of the entity.
 */
export const propertyCardLayoutGetPropertyCardLayoutByEntityIdOptions = (
    options: Options<PropertyCardLayoutGetPropertyCardLayoutByEntityIdData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await propertyCardLayoutGetPropertyCardLayoutByEntityId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: propertyCardLayoutGetPropertyCardLayoutByEntityIdQueryKey(options),
    });
};

export const jobTitlesGetCountQueryKey = (options: Options<JobTitlesGetCountData>) =>
    createQueryKey('jobTitlesGetCount', options);

/**
 * Returns the number of Job Titles.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ]
 * }
 */
export const jobTitlesGetCountOptions = (options: Options<JobTitlesGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Job Titles.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ]
 * }
 */
export const jobTitlesGetCountMutation = (
    options?: Partial<Options<JobTitlesGetCountData>>,
): UseMutationOptions<
    JobTitlesGetCountResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetCountResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetRelationsCountQueryKey = (
    options: Options<JobTitlesGetRelationsCountData>,
) => createQueryKey('jobTitlesGetRelationsCount', options);

/**
 * Returns the number of items related to a Job Title.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const jobTitlesGetRelationsCountOptions = (
    options: Options<JobTitlesGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Job Title.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const jobTitlesGetRelationsCountMutation = (
    options?: Partial<Options<JobTitlesGetRelationsCountData>>,
): UseMutationOptions<
    JobTitlesGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetQueryKey = (options: Options<JobTitlesGetData>) =>
    createQueryKey('jobTitlesGet', options);

/**
 * Returns a list of Job Titles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetOptions = (options: Options<JobTitlesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetQueryKey(options),
    });
};

export const jobTitlesGetInfiniteQueryKey = (
    options: Options<JobTitlesGetData>,
): QueryKey<Options<JobTitlesGetData>> => createQueryKey('jobTitlesGet', options, true);

/**
 * Returns a list of Job Titles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetInfiniteOptions = (options: Options<JobTitlesGetData>) => {
    return infiniteQueryOptions<
        JobTitlesGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<JobTitlesGetResponse>,
        QueryKey<Options<JobTitlesGetData>>,
        number | Pick<QueryKey<Options<JobTitlesGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<JobTitlesGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await jobTitlesGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: jobTitlesGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Job Titles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetMutation = (
    options?: Partial<Options<JobTitlesGetData>>,
): UseMutationOptions<
    JobTitlesGetResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetGroupedQueryKey = (options: Options<JobTitlesGetGroupedData>) =>
    createQueryKey('jobTitlesGetGrouped', options);

/**
 * Returns a grouped list of Job Titles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const jobTitlesGetGroupedOptions = (options: Options<JobTitlesGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetGroupedQueryKey(options),
    });
};

export const jobTitlesGetGroupedInfiniteQueryKey = (
    options: Options<JobTitlesGetGroupedData>,
): QueryKey<Options<JobTitlesGetGroupedData>> =>
    createQueryKey('jobTitlesGetGrouped', options, true);

/**
 * Returns a grouped list of Job Titles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const jobTitlesGetGroupedInfiniteOptions = (options: Options<JobTitlesGetGroupedData>) => {
    return infiniteQueryOptions<
        JobTitlesGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<JobTitlesGetGroupedResponse>,
        QueryKey<Options<JobTitlesGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<JobTitlesGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<JobTitlesGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await jobTitlesGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: jobTitlesGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Job Titles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const jobTitlesGetGroupedMutation = (
    options?: Partial<Options<JobTitlesGetGroupedData>>,
): UseMutationOptions<
    JobTitlesGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetByIdentifierQueryKey = (options: Options<JobTitlesGetByIdentifierData>) =>
    createQueryKey('jobTitlesGetByIdentifier', options);

/**
 * Returns a Job Title by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetByIdentifierOptions = (options: Options<JobTitlesGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Job Title by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetByIdentifierMutation = (
    options?: Partial<Options<JobTitlesGetByIdentifierData>>,
): UseMutationOptions<
    JobTitlesGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetByIdsQueryKey = (options: Options<JobTitlesGetByIdsData>) =>
    createQueryKey('jobTitlesGetByIds', options);

/**
 * Returns a list of Job Titles by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const jobTitlesGetByIdsOptions = (options: Options<JobTitlesGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetByIdsQueryKey(options),
    });
};

export const jobTitlesGetByIdsInfiniteQueryKey = (
    options: Options<JobTitlesGetByIdsData>,
): QueryKey<Options<JobTitlesGetByIdsData>> => createQueryKey('jobTitlesGetByIds', options, true);

/**
 * Returns a list of Job Titles by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const jobTitlesGetByIdsInfiniteOptions = (options: Options<JobTitlesGetByIdsData>) => {
    return infiniteQueryOptions<
        JobTitlesGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<JobTitlesGetByIdsResponse>,
        QueryKey<Options<JobTitlesGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<JobTitlesGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<JobTitlesGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await jobTitlesGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: jobTitlesGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Job Titles by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "JobTitle",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const jobTitlesGetByIdsMutation = (
    options?: Partial<Options<JobTitlesGetByIdsData>>,
): UseMutationOptions<
    JobTitlesGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetRelationsQueryKey = (options: Options<JobTitlesGetRelationsData>) =>
    createQueryKey('jobTitlesGetRelations', options);

/**
 * Returns a list of items related to a Job Title.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetRelationsOptions = (options: Options<JobTitlesGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetRelationsQueryKey(options),
    });
};

export const jobTitlesGetRelationsInfiniteQueryKey = (
    options: Options<JobTitlesGetRelationsData>,
): QueryKey<Options<JobTitlesGetRelationsData>> =>
    createQueryKey('jobTitlesGetRelations', options, true);

/**
 * Returns a list of items related to a Job Title.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetRelationsInfiniteOptions = (
    options: Options<JobTitlesGetRelationsData>,
) => {
    return infiniteQueryOptions<
        JobTitlesGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<JobTitlesGetRelationsResponse>,
        QueryKey<Options<JobTitlesGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<JobTitlesGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<JobTitlesGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await jobTitlesGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: jobTitlesGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Job Title.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const jobTitlesGetRelationsMutation = (
    options?: Partial<Options<JobTitlesGetRelationsData>>,
): UseMutationOptions<
    JobTitlesGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const jobTitlesGetGroupedRelationsQueryKey = (
    options: Options<JobTitlesGetGroupedRelationsData>,
) => createQueryKey('jobTitlesGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Job Title.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const jobTitlesGetGroupedRelationsOptions = (
    options: Options<JobTitlesGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jobTitlesGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: jobTitlesGetGroupedRelationsQueryKey(options),
    });
};

export const jobTitlesGetGroupedRelationsInfiniteQueryKey = (
    options: Options<JobTitlesGetGroupedRelationsData>,
): QueryKey<Options<JobTitlesGetGroupedRelationsData>> =>
    createQueryKey('jobTitlesGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Job Title.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const jobTitlesGetGroupedRelationsInfiniteOptions = (
    options: Options<JobTitlesGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        JobTitlesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<JobTitlesGetGroupedRelationsResponse>,
        QueryKey<Options<JobTitlesGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<JobTitlesGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<JobTitlesGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await jobTitlesGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: jobTitlesGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Job Title.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const jobTitlesGetGroupedRelationsMutation = (
    options?: Partial<Options<JobTitlesGetGroupedRelationsData>>,
): UseMutationOptions<
    JobTitlesGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<JobTitlesGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        JobTitlesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<JobTitlesGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await jobTitlesGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const membersGetAllMembersQueryKey = (options: Options<MembersGetAllMembersData>) =>
    createQueryKey('membersGetAllMembers', options);

/**
 * Returns a list of Members(AuthorizationGroups, UserGroups, ProfileGroups, Users).
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "user",
 * "itemType": "Text"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const membersGetAllMembersOptions = (options: Options<MembersGetAllMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await membersGetAllMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: membersGetAllMembersQueryKey(options),
    });
};

export const membersGetAllMembersInfiniteQueryKey = (
    options: Options<MembersGetAllMembersData>,
): QueryKey<Options<MembersGetAllMembersData>> =>
    createQueryKey('membersGetAllMembers', options, true);

/**
 * Returns a list of Members(AuthorizationGroups, UserGroups, ProfileGroups, Users).
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "user",
 * "itemType": "Text"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const membersGetAllMembersInfiniteOptions = (options: Options<MembersGetAllMembersData>) => {
    return infiniteQueryOptions<
        MembersGetAllMembersResponse,
        AxiosError<DefaultError>,
        InfiniteData<MembersGetAllMembersResponse>,
        QueryKey<Options<MembersGetAllMembersData>>,
        | number
        | Pick<
              QueryKey<Options<MembersGetAllMembersData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<MembersGetAllMembersData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await membersGetAllMembers({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: membersGetAllMembersInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Members(AuthorizationGroups, UserGroups, ProfileGroups, Users).
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "user",
 * "itemType": "Text"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const membersGetAllMembersMutation = (
    options?: Partial<Options<MembersGetAllMembersData>>,
): UseMutationOptions<
    MembersGetAllMembersResponse,
    AxiosError<DefaultError>,
    Options<MembersGetAllMembersData>
> => {
    const mutationOptions: UseMutationOptions<
        MembersGetAllMembersResponse,
        AxiosError<DefaultError>,
        Options<MembersGetAllMembersData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await membersGetAllMembers({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const profilesGetCountQueryKey = (options: Options<ProfilesGetCountData>) =>
    createQueryKey('profilesGetCount', options);

/**
 * Returns the number of Profiles.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ]
 * }
 */
export const profilesGetCountOptions = (options: Options<ProfilesGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await profilesGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: profilesGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Profiles.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ]
 * }
 */
export const profilesGetCountMutation = (
    options?: Partial<Options<ProfilesGetCountData>>,
): UseMutationOptions<
    ProfilesGetCountResponse,
    AxiosError<DefaultError>,
    Options<ProfilesGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        ProfilesGetCountResponse,
        AxiosError<DefaultError>,
        Options<ProfilesGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await profilesGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const profilesGetQueryKey = (options: Options<ProfilesGetData>) =>
    createQueryKey('profilesGet', options);

/**
 * Returns a list of Profiles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const profilesGetOptions = (options: Options<ProfilesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await profilesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: profilesGetQueryKey(options),
    });
};

export const profilesGetInfiniteQueryKey = (
    options: Options<ProfilesGetData>,
): QueryKey<Options<ProfilesGetData>> => createQueryKey('profilesGet', options, true);

/**
 * Returns a list of Profiles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const profilesGetInfiniteOptions = (options: Options<ProfilesGetData>) => {
    return infiniteQueryOptions<
        ProfilesGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProfilesGetResponse>,
        QueryKey<Options<ProfilesGetData>>,
        number | Pick<QueryKey<Options<ProfilesGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProfilesGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await profilesGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: profilesGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Profiles.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const profilesGetMutation = (
    options?: Partial<Options<ProfilesGetData>>,
): UseMutationOptions<ProfilesGetResponse, AxiosError<DefaultError>, Options<ProfilesGetData>> => {
    const mutationOptions: UseMutationOptions<
        ProfilesGetResponse,
        AxiosError<DefaultError>,
        Options<ProfilesGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await profilesGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const profilesGetByIdentifierQueryKey = (options: Options<ProfilesGetByIdentifierData>) =>
    createQueryKey('profilesGetByIdentifier', options);

/**
 * Returns a Profile by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const profilesGetByIdentifierOptions = (options: Options<ProfilesGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await profilesGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: profilesGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Profile by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const profilesGetByIdentifierMutation = (
    options?: Partial<Options<ProfilesGetByIdentifierData>>,
): UseMutationOptions<
    ProfilesGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<ProfilesGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        ProfilesGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<ProfilesGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await profilesGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const profilesGetByIdsQueryKey = (options: Options<ProfilesGetByIdsData>) =>
    createQueryKey('profilesGetByIds', options);

/**
 * Returns a list of Profiles by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const profilesGetByIdsOptions = (options: Options<ProfilesGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await profilesGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: profilesGetByIdsQueryKey(options),
    });
};

export const profilesGetByIdsInfiniteQueryKey = (
    options: Options<ProfilesGetByIdsData>,
): QueryKey<Options<ProfilesGetByIdsData>> => createQueryKey('profilesGetByIds', options, true);

/**
 * Returns a list of Profiles by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const profilesGetByIdsInfiniteOptions = (options: Options<ProfilesGetByIdsData>) => {
    return infiniteQueryOptions<
        ProfilesGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProfilesGetByIdsResponse>,
        QueryKey<Options<ProfilesGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<ProfilesGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProfilesGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await profilesGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: profilesGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Profiles by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Profile",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "Test"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const profilesGetByIdsMutation = (
    options?: Partial<Options<ProfilesGetByIdsData>>,
): UseMutationOptions<
    ProfilesGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<ProfilesGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProfilesGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<ProfilesGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await profilesGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const profilesGetUserProfilesQueryKey = (options: Options<ProfilesGetUserProfilesData>) =>
    createQueryKey('profilesGetUserProfiles', options);

/**
 * Returns a list of Profiles which are assigned to User.
 */
export const profilesGetUserProfilesOptions = (options: Options<ProfilesGetUserProfilesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await profilesGetUserProfiles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: profilesGetUserProfilesQueryKey(options),
    });
};

export const skillsGetQueryKey = (options: Options<SkillsGetData>) =>
    createQueryKey('skillsGet', options);

/**
 * Returns a list of Skills.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const skillsGetOptions = (options: Options<SkillsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetQueryKey(options),
    });
};

export const skillsGetInfiniteQueryKey = (
    options: Options<SkillsGetData>,
): QueryKey<Options<SkillsGetData>> => createQueryKey('skillsGet', options, true);

/**
 * Returns a list of Skills.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const skillsGetInfiniteOptions = (options: Options<SkillsGetData>) => {
    return infiniteQueryOptions<
        SkillsGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<SkillsGetResponse>,
        QueryKey<Options<SkillsGetData>>,
        number | Pick<QueryKey<Options<SkillsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<SkillsGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await skillsGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: skillsGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Skills.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const skillsGetMutation = (
    options?: Partial<Options<SkillsGetData>>,
): UseMutationOptions<SkillsGetResponse, AxiosError<DefaultError>, Options<SkillsGetData>> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetGroupedQueryKey = (options: Options<SkillsGetGroupedData>) =>
    createQueryKey('skillsGetGrouped', options);

/**
 * Returns a grouped list of Skills.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const skillsGetGroupedOptions = (options: Options<SkillsGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetGroupedQueryKey(options),
    });
};

export const skillsGetGroupedInfiniteQueryKey = (
    options: Options<SkillsGetGroupedData>,
): QueryKey<Options<SkillsGetGroupedData>> => createQueryKey('skillsGetGrouped', options, true);

/**
 * Returns a grouped list of Skills.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const skillsGetGroupedInfiniteOptions = (options: Options<SkillsGetGroupedData>) => {
    return infiniteQueryOptions<
        SkillsGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<SkillsGetGroupedResponse>,
        QueryKey<Options<SkillsGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<SkillsGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<SkillsGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await skillsGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: skillsGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Skills.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const skillsGetGroupedMutation = (
    options?: Partial<Options<SkillsGetGroupedData>>,
): UseMutationOptions<
    SkillsGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetByIdentifierQueryKey = (options: Options<SkillsGetByIdentifierData>) =>
    createQueryKey('skillsGetByIdentifier', options);

/**
 * Returns a Skill by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const skillsGetByIdentifierOptions = (options: Options<SkillsGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Skill by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const skillsGetByIdentifierMutation = (
    options?: Partial<Options<SkillsGetByIdentifierData>>,
): UseMutationOptions<
    SkillsGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetByIdsQueryKey = (options: Options<SkillsGetByIdsData>) =>
    createQueryKey('skillsGetByIds', options);

/**
 * Returns a list of Skills by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const skillsGetByIdsOptions = (options: Options<SkillsGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetByIdsQueryKey(options),
    });
};

export const skillsGetByIdsInfiniteQueryKey = (
    options: Options<SkillsGetByIdsData>,
): QueryKey<Options<SkillsGetByIdsData>> => createQueryKey('skillsGetByIds', options, true);

/**
 * Returns a list of Skills by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const skillsGetByIdsInfiniteOptions = (options: Options<SkillsGetByIdsData>) => {
    return infiniteQueryOptions<
        SkillsGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<SkillsGetByIdsResponse>,
        QueryKey<Options<SkillsGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<SkillsGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<SkillsGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await skillsGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: skillsGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Skills by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const skillsGetByIdsMutation = (
    options?: Partial<Options<SkillsGetByIdsData>>,
): UseMutationOptions<
    SkillsGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetCountQueryKey = (options: Options<SkillsGetCountData>) =>
    createQueryKey('skillsGetCount', options);

/**
 * Returns the number of Skills.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ]
 * }
 */
export const skillsGetCountOptions = (options: Options<SkillsGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Skills.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Skill",
 * "fieldName": "NLRCategory"
 * },
 * "operator": "In",
 * "filterValueType": "PickList",
 * "values": [
 * {
 * "value": "Labor"
 * }
 * ]
 * }
 * ]
 * }
 */
export const skillsGetCountMutation = (
    options?: Partial<Options<SkillsGetCountData>>,
): UseMutationOptions<
    SkillsGetCountResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetCountResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetRelationsQueryKey = (options: Options<SkillsGetRelationsData>) =>
    createQueryKey('skillsGetRelations', options);

/**
 * Returns a list of items related to a Skill.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const skillsGetRelationsOptions = (options: Options<SkillsGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetRelationsQueryKey(options),
    });
};

export const skillsGetRelationsInfiniteQueryKey = (
    options: Options<SkillsGetRelationsData>,
): QueryKey<Options<SkillsGetRelationsData>> => createQueryKey('skillsGetRelations', options, true);

/**
 * Returns a list of items related to a Skill.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const skillsGetRelationsInfiniteOptions = (options: Options<SkillsGetRelationsData>) => {
    return infiniteQueryOptions<
        SkillsGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<SkillsGetRelationsResponse>,
        QueryKey<Options<SkillsGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<SkillsGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<SkillsGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await skillsGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: skillsGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Skill.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const skillsGetRelationsMutation = (
    options?: Partial<Options<SkillsGetRelationsData>>,
): UseMutationOptions<
    SkillsGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetRelationsCountQueryKey = (options: Options<SkillsGetRelationsCountData>) =>
    createQueryKey('skillsGetRelationsCount', options);

/**
 * Returns the number of items related to a Skill.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ]
 * }
 */
export const skillsGetRelationsCountOptions = (options: Options<SkillsGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Skill.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ]
 * }
 */
export const skillsGetRelationsCountMutation = (
    options?: Partial<Options<SkillsGetRelationsCountData>>,
): UseMutationOptions<
    SkillsGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const skillsGetGroupedRelationsQueryKey = (
    options: Options<SkillsGetGroupedRelationsData>,
) => createQueryKey('skillsGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Skill.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const skillsGetGroupedRelationsOptions = (
    options: Options<SkillsGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await skillsGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: skillsGetGroupedRelationsQueryKey(options),
    });
};

export const skillsGetGroupedRelationsInfiniteQueryKey = (
    options: Options<SkillsGetGroupedRelationsData>,
): QueryKey<Options<SkillsGetGroupedRelationsData>> =>
    createQueryKey('skillsGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Skill.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const skillsGetGroupedRelationsInfiniteOptions = (
    options: Options<SkillsGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        SkillsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<SkillsGetGroupedRelationsResponse>,
        QueryKey<Options<SkillsGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<SkillsGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<SkillsGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await skillsGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: skillsGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Skill.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "ResourceEntity",
 * "fieldName": "Name"
 * },
 * "operator": "Equals",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "User1"
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const skillsGetGroupedRelationsMutation = (
    options?: Partial<Options<SkillsGetGroupedRelationsData>>,
): UseMutationOptions<
    SkillsGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<SkillsGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        SkillsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<SkillsGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await skillsGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetQueryKey = (options: Options<UserGroupsGetData>) =>
    createQueryKey('userGroupsGet', options);

/**
 * Returns a list of User Groups.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetOptions = (options: Options<UserGroupsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetQueryKey(options),
    });
};

export const userGroupsGetInfiniteQueryKey = (
    options: Options<UserGroupsGetData>,
): QueryKey<Options<UserGroupsGetData>> => createQueryKey('userGroupsGet', options, true);

/**
 * Returns a list of User Groups.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetInfiniteOptions = (options: Options<UserGroupsGetData>) => {
    return infiniteQueryOptions<
        UserGroupsGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<UserGroupsGetResponse>,
        QueryKey<Options<UserGroupsGetData>>,
        | number
        | Pick<QueryKey<Options<UserGroupsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UserGroupsGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await userGroupsGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: userGroupsGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of User Groups.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetMutation = (
    options?: Partial<Options<UserGroupsGetData>>,
): UseMutationOptions<
    UserGroupsGetResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetGroupedQueryKey = (options: Options<UserGroupsGetGroupedData>) =>
    createQueryKey('userGroupsGetGrouped', options);

/**
 * Returns a grouped list of User Groups.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const userGroupsGetGroupedOptions = (options: Options<UserGroupsGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetGroupedQueryKey(options),
    });
};

export const userGroupsGetGroupedInfiniteQueryKey = (
    options: Options<UserGroupsGetGroupedData>,
): QueryKey<Options<UserGroupsGetGroupedData>> =>
    createQueryKey('userGroupsGetGrouped', options, true);

/**
 * Returns a grouped list of User Groups.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const userGroupsGetGroupedInfiniteOptions = (options: Options<UserGroupsGetGroupedData>) => {
    return infiniteQueryOptions<
        UserGroupsGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<UserGroupsGetGroupedResponse>,
        QueryKey<Options<UserGroupsGetGroupedData>>,
        | number
        | Pick<
              QueryKey<Options<UserGroupsGetGroupedData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UserGroupsGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await userGroupsGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: userGroupsGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of User Groups.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const userGroupsGetGroupedMutation = (
    options?: Partial<Options<UserGroupsGetGroupedData>>,
): UseMutationOptions<
    UserGroupsGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetByIdentifierQueryKey = (
    options: Options<UserGroupsGetByIdentifierData>,
) => createQueryKey('userGroupsGetByIdentifier', options);

/**
 * Returns a User Group by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const userGroupsGetByIdentifierOptions = (
    options: Options<UserGroupsGetByIdentifierData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a User Group by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const userGroupsGetByIdentifierMutation = (
    options?: Partial<Options<UserGroupsGetByIdentifierData>>,
): UseMutationOptions<
    UserGroupsGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetByIdsQueryKey = (options: Options<UserGroupsGetByIdsData>) =>
    createQueryKey('userGroupsGetByIds', options);

/**
 * Returns a list of User Groups by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const userGroupsGetByIdsOptions = (options: Options<UserGroupsGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetByIdsQueryKey(options),
    });
};

export const userGroupsGetByIdsInfiniteQueryKey = (
    options: Options<UserGroupsGetByIdsData>,
): QueryKey<Options<UserGroupsGetByIdsData>> => createQueryKey('userGroupsGetByIds', options, true);

/**
 * Returns a list of User Groups by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const userGroupsGetByIdsInfiniteOptions = (options: Options<UserGroupsGetByIdsData>) => {
    return infiniteQueryOptions<
        UserGroupsGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<UserGroupsGetByIdsResponse>,
        QueryKey<Options<UserGroupsGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<UserGroupsGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UserGroupsGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await userGroupsGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: userGroupsGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of User Groups by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const userGroupsGetByIdsMutation = (
    options?: Partial<Options<UserGroupsGetByIdsData>>,
): UseMutationOptions<
    UserGroupsGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetCountQueryKey = (options: Options<UserGroupsGetCountData>) =>
    createQueryKey('userGroupsGetCount', options);

/**
 * Returns the number of User Groups.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ]
 * }
 */
export const userGroupsGetCountOptions = (options: Options<UserGroupsGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetCountQueryKey(options),
    });
};

/**
 * Returns the number of User Groups.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ]
 * }
 */
export const userGroupsGetCountMutation = (
    options?: Partial<Options<UserGroupsGetCountData>>,
): UseMutationOptions<
    UserGroupsGetCountResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetCountResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetRelationsQueryKey = (options: Options<UserGroupsGetRelationsData>) =>
    createQueryKey('userGroupsGetRelations', options);

/**
 * Returns a list of items related to a User Group.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetRelationsOptions = (options: Options<UserGroupsGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetRelationsQueryKey(options),
    });
};

export const userGroupsGetRelationsInfiniteQueryKey = (
    options: Options<UserGroupsGetRelationsData>,
): QueryKey<Options<UserGroupsGetRelationsData>> =>
    createQueryKey('userGroupsGetRelations', options, true);

/**
 * Returns a list of items related to a User Group.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetRelationsInfiniteOptions = (
    options: Options<UserGroupsGetRelationsData>,
) => {
    return infiniteQueryOptions<
        UserGroupsGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<UserGroupsGetRelationsResponse>,
        QueryKey<Options<UserGroupsGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<UserGroupsGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UserGroupsGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await userGroupsGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: userGroupsGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a User Group.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetRelationsMutation = (
    options?: Partial<Options<UserGroupsGetRelationsData>>,
): UseMutationOptions<
    UserGroupsGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetRelationsCountQueryKey = (
    options: Options<UserGroupsGetRelationsCountData>,
) => createQueryKey('userGroupsGetRelationsCount', options);

/**
 * Returns the number of items related to a User Group.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const userGroupsGetRelationsCountOptions = (
    options: Options<UserGroupsGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a User Group.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const userGroupsGetRelationsCountMutation = (
    options?: Partial<Options<UserGroupsGetRelationsCountData>>,
): UseMutationOptions<
    UserGroupsGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetGroupedRelationsQueryKey = (
    options: Options<UserGroupsGetGroupedRelationsData>,
) => createQueryKey('userGroupsGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a User Group.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const userGroupsGetGroupedRelationsOptions = (
    options: Options<UserGroupsGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetGroupedRelationsQueryKey(options),
    });
};

export const userGroupsGetGroupedRelationsInfiniteQueryKey = (
    options: Options<UserGroupsGetGroupedRelationsData>,
): QueryKey<Options<UserGroupsGetGroupedRelationsData>> =>
    createQueryKey('userGroupsGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a User Group.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const userGroupsGetGroupedRelationsInfiniteOptions = (
    options: Options<UserGroupsGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        UserGroupsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<UserGroupsGetGroupedRelationsResponse>,
        QueryKey<Options<UserGroupsGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<UserGroupsGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UserGroupsGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await userGroupsGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: userGroupsGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a User Group.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const userGroupsGetGroupedRelationsMutation = (
    options?: Partial<Options<UserGroupsGetGroupedRelationsData>>,
): UseMutationOptions<
    UserGroupsGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const userGroupsGetAuthorizationGroupsQueryKey = (
    options?: Options<UserGroupsGetAuthorizationGroupsData>,
) => createQueryKey('userGroupsGetAuthorizationGroups', options);

/**
 * Returns a list of Authorization Groups.
 */
export const userGroupsGetAuthorizationGroupsOptions = (
    options?: Options<UserGroupsGetAuthorizationGroupsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetAuthorizationGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetAuthorizationGroupsQueryKey(options),
    });
};

export const userGroupsGetRelatedGroupsForUserQueryKey = (
    options: Options<UserGroupsGetRelatedGroupsForUserData>,
) => createQueryKey('userGroupsGetRelatedGroupsForUser', options);

/**
 * Returns a list of Groups which the User is a member of.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetRelatedGroupsForUserOptions = (
    options: Options<UserGroupsGetRelatedGroupsForUserData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userGroupsGetRelatedGroupsForUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: userGroupsGetRelatedGroupsForUserQueryKey(options),
    });
};

export const userGroupsGetRelatedGroupsForUserInfiniteQueryKey = (
    options: Options<UserGroupsGetRelatedGroupsForUserData>,
): QueryKey<Options<UserGroupsGetRelatedGroupsForUserData>> =>
    createQueryKey('userGroupsGetRelatedGroupsForUser', options, true);

/**
 * Returns a list of Groups which the User is a member of.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetRelatedGroupsForUserInfiniteOptions = (
    options: Options<UserGroupsGetRelatedGroupsForUserData>,
) => {
    return infiniteQueryOptions<
        UserGroupsGetRelatedGroupsForUserResponse,
        AxiosError<DefaultError>,
        InfiniteData<UserGroupsGetRelatedGroupsForUserResponse>,
        QueryKey<Options<UserGroupsGetRelatedGroupsForUserData>>,
        | number
        | Pick<
              QueryKey<Options<UserGroupsGetRelatedGroupsForUserData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UserGroupsGetRelatedGroupsForUserData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await userGroupsGetRelatedGroupsForUser({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: userGroupsGetRelatedGroupsForUserInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Groups which the User is a member of.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "UserGroup",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const userGroupsGetRelatedGroupsForUserMutation = (
    options?: Partial<Options<UserGroupsGetRelatedGroupsForUserData>>,
): UseMutationOptions<
    UserGroupsGetRelatedGroupsForUserResponse,
    AxiosError<DefaultError>,
    Options<UserGroupsGetRelatedGroupsForUserData>
> => {
    const mutationOptions: UseMutationOptions<
        UserGroupsGetRelatedGroupsForUserResponse,
        AxiosError<DefaultError>,
        Options<UserGroupsGetRelatedGroupsForUserData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await userGroupsGetRelatedGroupsForUser({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetQueryKey = (options: Options<UsersGetData>) =>
    createQueryKey('usersGet', options);

/**
 * Returns a list of Users.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const usersGetOptions = (options: Options<UsersGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetQueryKey(options),
    });
};

export const usersGetInfiniteQueryKey = (
    options: Options<UsersGetData>,
): QueryKey<Options<UsersGetData>> => createQueryKey('usersGet', options, true);

/**
 * Returns a list of Users.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const usersGetInfiniteOptions = (options: Options<UsersGetData>) => {
    return infiniteQueryOptions<
        UsersGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<UsersGetResponse>,
        QueryKey<Options<UsersGetData>>,
        number | Pick<QueryKey<Options<UsersGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UsersGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await usersGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: usersGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Users.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const usersGetMutation = (
    options?: Partial<Options<UsersGetData>>,
): UseMutationOptions<UsersGetResponse, AxiosError<DefaultError>, Options<UsersGetData>> => {
    const mutationOptions: UseMutationOptions<
        UsersGetResponse,
        AxiosError<DefaultError>,
        Options<UsersGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetGroupedQueryKey = (options: Options<UsersGetGroupedData>) =>
    createQueryKey('usersGetGrouped', options);

/**
 * Returns a grouped list of Users.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const usersGetGroupedOptions = (options: Options<UsersGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetGroupedQueryKey(options),
    });
};

export const usersGetGroupedInfiniteQueryKey = (
    options: Options<UsersGetGroupedData>,
): QueryKey<Options<UsersGetGroupedData>> => createQueryKey('usersGetGrouped', options, true);

/**
 * Returns a grouped list of Users.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const usersGetGroupedInfiniteOptions = (options: Options<UsersGetGroupedData>) => {
    return infiniteQueryOptions<
        UsersGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<UsersGetGroupedResponse>,
        QueryKey<Options<UsersGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<UsersGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UsersGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await usersGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: usersGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Users.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const usersGetGroupedMutation = (
    options?: Partial<Options<UsersGetGroupedData>>,
): UseMutationOptions<
    UsersGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<UsersGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<UsersGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetByIdentifierQueryKey = (options: Options<UsersGetByIdentifierData>) =>
    createQueryKey('usersGetByIdentifier', options);

/**
 * Returns a User by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const usersGetByIdentifierOptions = (options: Options<UsersGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a User by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const usersGetByIdentifierMutation = (
    options?: Partial<Options<UsersGetByIdentifierData>>,
): UseMutationOptions<
    UsersGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<UsersGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<UsersGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetByIdsQueryKey = (options: Options<UsersGetByIdsData>) =>
    createQueryKey('usersGetByIds', options);

/**
 * Returns a list of Users by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const usersGetByIdsOptions = (options: Options<UsersGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetByIdsQueryKey(options),
    });
};

export const usersGetByIdsInfiniteQueryKey = (
    options: Options<UsersGetByIdsData>,
): QueryKey<Options<UsersGetByIdsData>> => createQueryKey('usersGetByIds', options, true);

/**
 * Returns a list of Users by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const usersGetByIdsInfiniteOptions = (options: Options<UsersGetByIdsData>) => {
    return infiniteQueryOptions<
        UsersGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<UsersGetByIdsResponse>,
        QueryKey<Options<UsersGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<UsersGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UsersGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await usersGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: usersGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Users by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const usersGetByIdsMutation = (
    options?: Partial<Options<UsersGetByIdsData>>,
): UseMutationOptions<
    UsersGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<UsersGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<UsersGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetCountQueryKey = (options: Options<UsersGetCountData>) =>
    createQueryKey('usersGetCount', options);

/**
 * Returns the number of Users.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ]
 * }
 */
export const usersGetCountOptions = (options: Options<UsersGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Users.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "User",
 * "fieldName": "RevenueRegularRate"
 * },
 * "operator": "GreaterThan",
 * "filterValueType": "NumericWithUnit",
 * "values": [
 * {
 * "value":{
 * "amount": 5,
 * "unit": "USD"
 * }
 * }
 * ]
 * }
 * ]
 * }
 */
export const usersGetCountMutation = (
    options?: Partial<Options<UsersGetCountData>>,
): UseMutationOptions<
    UsersGetCountResponse,
    AxiosError<DefaultError>,
    Options<UsersGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetCountResponse,
        AxiosError<DefaultError>,
        Options<UsersGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetRelationsQueryKey = (options: Options<UsersGetRelationsData>) =>
    createQueryKey('usersGetRelations', options);

/**
 * Returns a list of items related to a User.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const usersGetRelationsOptions = (options: Options<UsersGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetRelationsQueryKey(options),
    });
};

export const usersGetRelationsInfiniteQueryKey = (
    options: Options<UsersGetRelationsData>,
): QueryKey<Options<UsersGetRelationsData>> => createQueryKey('usersGetRelations', options, true);

/**
 * Returns a list of items related to a User.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const usersGetRelationsInfiniteOptions = (options: Options<UsersGetRelationsData>) => {
    return infiniteQueryOptions<
        UsersGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<UsersGetRelationsResponse>,
        QueryKey<Options<UsersGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<UsersGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UsersGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await usersGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: usersGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a User.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const usersGetRelationsMutation = (
    options?: Partial<Options<UsersGetRelationsData>>,
): UseMutationOptions<
    UsersGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<UsersGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<UsersGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetRelationsCountQueryKey = (options: Options<UsersGetRelationsCountData>) =>
    createQueryKey('usersGetRelationsCount', options);

/**
 * Returns the number of items related to a User.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const usersGetRelationsCountOptions = (options: Options<UsersGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a User.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const usersGetRelationsCountMutation = (
    options?: Partial<Options<UsersGetRelationsCountData>>,
): UseMutationOptions<
    UsersGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<UsersGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<UsersGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const usersGetGroupedRelationsQueryKey = (options: Options<UsersGetGroupedRelationsData>) =>
    createQueryKey('usersGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a User.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const usersGetGroupedRelationsOptions = (options: Options<UsersGetGroupedRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: usersGetGroupedRelationsQueryKey(options),
    });
};

export const usersGetGroupedRelationsInfiniteQueryKey = (
    options: Options<UsersGetGroupedRelationsData>,
): QueryKey<Options<UsersGetGroupedRelationsData>> =>
    createQueryKey('usersGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a User.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const usersGetGroupedRelationsInfiniteOptions = (
    options: Options<UsersGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        UsersGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<UsersGetGroupedRelationsResponse>,
        QueryKey<Options<UsersGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<UsersGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<UsersGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await usersGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: usersGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a User.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "WorkItem",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const usersGetGroupedRelationsMutation = (
    options?: Partial<Options<UsersGetGroupedRelationsData>>,
): UseMutationOptions<
    UsersGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<UsersGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        UsersGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<UsersGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await usersGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const ribbonActionsGetRibbonActionsQueryKey = (
    options: Options<RibbonActionsGetRibbonActionsData>,
) => createQueryKey('ribbonActionsGetRibbonActions', options);

/**
 * Returns a list of Ribbon Actions
 * Sample request:
 *
 * {
 * "Ids": [],
 * "RibbonType": "Subsystem",
 * "EntityType": "Project",
 * "MainEntityId": "",
 * "ParentEntityId": ""
 * }
 */
export const ribbonActionsGetRibbonActionsOptions = (
    options: Options<RibbonActionsGetRibbonActionsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ribbonActionsGetRibbonActions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: ribbonActionsGetRibbonActionsQueryKey(options),
    });
};

/**
 * Returns a list of Ribbon Actions
 * Sample request:
 *
 * {
 * "Ids": [],
 * "RibbonType": "Subsystem",
 * "EntityType": "Project",
 * "MainEntityId": "",
 * "ParentEntityId": ""
 * }
 */
export const ribbonActionsGetRibbonActionsMutation = (
    options?: Partial<Options<RibbonActionsGetRibbonActionsData>>,
): UseMutationOptions<
    RibbonActionsGetRibbonActionsResponse,
    AxiosError<DefaultError>,
    Options<RibbonActionsGetRibbonActionsData>
> => {
    const mutationOptions: UseMutationOptions<
        RibbonActionsGetRibbonActionsResponse,
        AxiosError<DefaultError>,
        Options<RibbonActionsGetRibbonActionsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await ribbonActionsGetRibbonActions({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const ribbonActionsGetContextMenusQueryKey = (
    options: Options<RibbonActionsGetContextMenusData>,
) => createQueryKey('ribbonActionsGetContextMenus', options);

/**
 * Return context menus for a related entity
 */
export const ribbonActionsGetContextMenusOptions = (
    options: Options<RibbonActionsGetContextMenusData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ribbonActionsGetContextMenus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: ribbonActionsGetContextMenusQueryKey(options),
    });
};

/**
 * Return context menus for a related entity
 */
export const ribbonActionsGetContextMenusMutation = (
    options?: Partial<Options<RibbonActionsGetContextMenusData>>,
): UseMutationOptions<
    RibbonActionsGetContextMenusResponse,
    AxiosError<DefaultError>,
    Options<RibbonActionsGetContextMenusData>
> => {
    const mutationOptions: UseMutationOptions<
        RibbonActionsGetContextMenusResponse,
        AxiosError<DefaultError>,
        Options<RibbonActionsGetContextMenusData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await ribbonActionsGetContextMenus({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetQueryKey = (options: Options<MilestonesGetData>) =>
    createQueryKey('milestonesGet', options);

/**
 * Returns a list of Milestones.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const milestonesGetOptions = (options: Options<MilestonesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetQueryKey(options),
    });
};

export const milestonesGetInfiniteQueryKey = (
    options: Options<MilestonesGetData>,
): QueryKey<Options<MilestonesGetData>> => createQueryKey('milestonesGet', options, true);

/**
 * Returns a list of Milestones.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const milestonesGetInfiniteOptions = (options: Options<MilestonesGetData>) => {
    return infiniteQueryOptions<
        MilestonesGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<MilestonesGetResponse>,
        QueryKey<Options<MilestonesGetData>>,
        | number
        | Pick<QueryKey<Options<MilestonesGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<MilestonesGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await milestonesGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: milestonesGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Milestones.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const milestonesGetMutation = (
    options?: Partial<Options<MilestonesGetData>>,
): UseMutationOptions<
    MilestonesGetResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetGroupedQueryKey = (options: Options<MilestonesGetGroupedData>) =>
    createQueryKey('milestonesGetGrouped', options);

/**
 * Returns a grouped list of Milestones.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const milestonesGetGroupedOptions = (options: Options<MilestonesGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetGroupedQueryKey(options),
    });
};

export const milestonesGetGroupedInfiniteQueryKey = (
    options: Options<MilestonesGetGroupedData>,
): QueryKey<Options<MilestonesGetGroupedData>> =>
    createQueryKey('milestonesGetGrouped', options, true);

/**
 * Returns a grouped list of Milestones.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const milestonesGetGroupedInfiniteOptions = (options: Options<MilestonesGetGroupedData>) => {
    return infiniteQueryOptions<
        MilestonesGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<MilestonesGetGroupedResponse>,
        QueryKey<Options<MilestonesGetGroupedData>>,
        | number
        | Pick<
              QueryKey<Options<MilestonesGetGroupedData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<MilestonesGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await milestonesGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: milestonesGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Milestones.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const milestonesGetGroupedMutation = (
    options?: Partial<Options<MilestonesGetGroupedData>>,
): UseMutationOptions<
    MilestonesGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetByIdentifierQueryKey = (
    options: Options<MilestonesGetByIdentifierData>,
) => createQueryKey('milestonesGetByIdentifier', options);

/**
 * Returns a Milestone by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const milestonesGetByIdentifierOptions = (
    options: Options<MilestonesGetByIdentifierData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Milestone by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const milestonesGetByIdentifierMutation = (
    options?: Partial<Options<MilestonesGetByIdentifierData>>,
): UseMutationOptions<
    MilestonesGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetByIdsQueryKey = (options: Options<MilestonesGetByIdsData>) =>
    createQueryKey('milestonesGetByIds', options);

/**
 * Returns a list of Milestones by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const milestonesGetByIdsOptions = (options: Options<MilestonesGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetByIdsQueryKey(options),
    });
};

export const milestonesGetByIdsInfiniteQueryKey = (
    options: Options<MilestonesGetByIdsData>,
): QueryKey<Options<MilestonesGetByIdsData>> => createQueryKey('milestonesGetByIds', options, true);

/**
 * Returns a list of Milestones by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const milestonesGetByIdsInfiniteOptions = (options: Options<MilestonesGetByIdsData>) => {
    return infiniteQueryOptions<
        MilestonesGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<MilestonesGetByIdsResponse>,
        QueryKey<Options<MilestonesGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<MilestonesGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<MilestonesGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await milestonesGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: milestonesGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Milestones by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const milestonesGetByIdsMutation = (
    options?: Partial<Options<MilestonesGetByIdsData>>,
): UseMutationOptions<
    MilestonesGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetCountQueryKey = (options: Options<MilestonesGetCountData>) =>
    createQueryKey('milestonesGetCount', options);

/**
 * Returns the number of Milestones.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetCountOptions = (options: Options<MilestonesGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Milestones.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetCountMutation = (
    options?: Partial<Options<MilestonesGetCountData>>,
): UseMutationOptions<
    MilestonesGetCountResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetCountResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetRelationsQueryKey = (options: Options<MilestonesGetRelationsData>) =>
    createQueryKey('milestonesGetRelations', options);

/**
 * Returns a list of items related to a Milestone.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const milestonesGetRelationsOptions = (options: Options<MilestonesGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetRelationsQueryKey(options),
    });
};

export const milestonesGetRelationsInfiniteQueryKey = (
    options: Options<MilestonesGetRelationsData>,
): QueryKey<Options<MilestonesGetRelationsData>> =>
    createQueryKey('milestonesGetRelations', options, true);

/**
 * Returns a list of items related to a Milestone.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const milestonesGetRelationsInfiniteOptions = (
    options: Options<MilestonesGetRelationsData>,
) => {
    return infiniteQueryOptions<
        MilestonesGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<MilestonesGetRelationsResponse>,
        QueryKey<Options<MilestonesGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<MilestonesGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<MilestonesGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await milestonesGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: milestonesGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Milestone.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const milestonesGetRelationsMutation = (
    options?: Partial<Options<MilestonesGetRelationsData>>,
): UseMutationOptions<
    MilestonesGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetRelationsCountQueryKey = (
    options: Options<MilestonesGetRelationsCountData>,
) => createQueryKey('milestonesGetRelationsCount', options);

/**
 * Returns the number of items related to a Milestone.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetRelationsCountOptions = (
    options: Options<MilestonesGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Milestone.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetRelationsCountMutation = (
    options?: Partial<Options<MilestonesGetRelationsCountData>>,
): UseMutationOptions<
    MilestonesGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetGroupedRelationsQueryKey = (
    options: Options<MilestonesGetGroupedRelationsData>,
) => createQueryKey('milestonesGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Milestone.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const milestonesGetGroupedRelationsOptions = (
    options: Options<MilestonesGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetGroupedRelationsQueryKey(options),
    });
};

export const milestonesGetGroupedRelationsInfiniteQueryKey = (
    options: Options<MilestonesGetGroupedRelationsData>,
): QueryKey<Options<MilestonesGetGroupedRelationsData>> =>
    createQueryKey('milestonesGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Milestone.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const milestonesGetGroupedRelationsInfiniteOptions = (
    options: Options<MilestonesGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        MilestonesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<MilestonesGetGroupedRelationsResponse>,
        QueryKey<Options<MilestonesGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<MilestonesGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<MilestonesGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await milestonesGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: milestonesGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Milestone.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const milestonesGetGroupedRelationsMutation = (
    options?: Partial<Options<MilestonesGetGroupedRelationsData>>,
): UseMutationOptions<
    MilestonesGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetAvatarsQueryKey = (options: Options<MilestonesGetAvatarsData>) =>
    createQueryKey('milestonesGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetAvatarsOptions = (options: Options<MilestonesGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Milestone",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetAvatarsMutation = (
    options?: Partial<Options<MilestonesGetAvatarsData>>,
): UseMutationOptions<
    MilestonesGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const milestonesGetRelationsAvatarsQueryKey = (
    options: Options<MilestonesGetRelationsAvatarsData>,
) => createQueryKey('milestonesGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetRelationsAvatarsOptions = (
    options: Options<MilestonesGetRelationsAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await milestonesGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: milestonesGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const milestonesGetRelationsAvatarsMutation = (
    options?: Partial<Options<MilestonesGetRelationsAvatarsData>>,
): UseMutationOptions<
    MilestonesGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<MilestonesGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        MilestonesGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<MilestonesGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await milestonesGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetQueryKey = (options: Options<ProgramsGetData>) =>
    createQueryKey('programsGet', options);

/**
 * Returns a list of Programs.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const programsGetOptions = (options: Options<ProgramsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetQueryKey(options),
    });
};

export const programsGetInfiniteQueryKey = (
    options: Options<ProgramsGetData>,
): QueryKey<Options<ProgramsGetData>> => createQueryKey('programsGet', options, true);

/**
 * Returns a list of Programs.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const programsGetInfiniteOptions = (options: Options<ProgramsGetData>) => {
    return infiniteQueryOptions<
        ProgramsGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProgramsGetResponse>,
        QueryKey<Options<ProgramsGetData>>,
        number | Pick<QueryKey<Options<ProgramsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProgramsGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await programsGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: programsGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Programs.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const programsGetMutation = (
    options?: Partial<Options<ProgramsGetData>>,
): UseMutationOptions<ProgramsGetResponse, AxiosError<DefaultError>, Options<ProgramsGetData>> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetGroupedQueryKey = (options: Options<ProgramsGetGroupedData>) =>
    createQueryKey('programsGetGrouped', options);

/**
 * Returns a grouped list of Programs.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const programsGetGroupedOptions = (options: Options<ProgramsGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetGroupedQueryKey(options),
    });
};

export const programsGetGroupedInfiniteQueryKey = (
    options: Options<ProgramsGetGroupedData>,
): QueryKey<Options<ProgramsGetGroupedData>> => createQueryKey('programsGetGrouped', options, true);

/**
 * Returns a grouped list of Programs.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const programsGetGroupedInfiniteOptions = (options: Options<ProgramsGetGroupedData>) => {
    return infiniteQueryOptions<
        ProgramsGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProgramsGetGroupedResponse>,
        QueryKey<Options<ProgramsGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<ProgramsGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProgramsGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await programsGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: programsGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Programs.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const programsGetGroupedMutation = (
    options?: Partial<Options<ProgramsGetGroupedData>>,
): UseMutationOptions<
    ProgramsGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetByIdentifierQueryKey = (options: Options<ProgramsGetByIdentifierData>) =>
    createQueryKey('programsGetByIdentifier', options);

/**
 * Returns a Program by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const programsGetByIdentifierOptions = (options: Options<ProgramsGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Program by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const programsGetByIdentifierMutation = (
    options?: Partial<Options<ProgramsGetByIdentifierData>>,
): UseMutationOptions<
    ProgramsGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetByIdsQueryKey = (options: Options<ProgramsGetByIdsData>) =>
    createQueryKey('programsGetByIds', options);

/**
 * Returns a list of Programs by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const programsGetByIdsOptions = (options: Options<ProgramsGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetByIdsQueryKey(options),
    });
};

export const programsGetByIdsInfiniteQueryKey = (
    options: Options<ProgramsGetByIdsData>,
): QueryKey<Options<ProgramsGetByIdsData>> => createQueryKey('programsGetByIds', options, true);

/**
 * Returns a list of Programs by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const programsGetByIdsInfiniteOptions = (options: Options<ProgramsGetByIdsData>) => {
    return infiniteQueryOptions<
        ProgramsGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProgramsGetByIdsResponse>,
        QueryKey<Options<ProgramsGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<ProgramsGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProgramsGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await programsGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: programsGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Programs by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const programsGetByIdsMutation = (
    options?: Partial<Options<ProgramsGetByIdsData>>,
): UseMutationOptions<
    ProgramsGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetCountQueryKey = (options: Options<ProgramsGetCountData>) =>
    createQueryKey('programsGetCount', options);

/**
 * Returns the number of Programs.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetCountOptions = (options: Options<ProgramsGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Programs.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetCountMutation = (
    options?: Partial<Options<ProgramsGetCountData>>,
): UseMutationOptions<
    ProgramsGetCountResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetCountResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetRelationsQueryKey = (options: Options<ProgramsGetRelationsData>) =>
    createQueryKey('programsGetRelations', options);

/**
 * Returns a list of items related to a Program.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const programsGetRelationsOptions = (options: Options<ProgramsGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetRelationsQueryKey(options),
    });
};

export const programsGetRelationsInfiniteQueryKey = (
    options: Options<ProgramsGetRelationsData>,
): QueryKey<Options<ProgramsGetRelationsData>> =>
    createQueryKey('programsGetRelations', options, true);

/**
 * Returns a list of items related to a Program.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const programsGetRelationsInfiniteOptions = (options: Options<ProgramsGetRelationsData>) => {
    return infiniteQueryOptions<
        ProgramsGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProgramsGetRelationsResponse>,
        QueryKey<Options<ProgramsGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<ProgramsGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProgramsGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await programsGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: programsGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Program.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const programsGetRelationsMutation = (
    options?: Partial<Options<ProgramsGetRelationsData>>,
): UseMutationOptions<
    ProgramsGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetRelationsCountQueryKey = (
    options: Options<ProgramsGetRelationsCountData>,
) => createQueryKey('programsGetRelationsCount', options);

/**
 * Returns the number of items related to a Program.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetRelationsCountOptions = (
    options: Options<ProgramsGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Program.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetRelationsCountMutation = (
    options?: Partial<Options<ProgramsGetRelationsCountData>>,
): UseMutationOptions<
    ProgramsGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetGroupedRelationsQueryKey = (
    options: Options<ProgramsGetGroupedRelationsData>,
) => createQueryKey('programsGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Program.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const programsGetGroupedRelationsOptions = (
    options: Options<ProgramsGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetGroupedRelationsQueryKey(options),
    });
};

export const programsGetGroupedRelationsInfiniteQueryKey = (
    options: Options<ProgramsGetGroupedRelationsData>,
): QueryKey<Options<ProgramsGetGroupedRelationsData>> =>
    createQueryKey('programsGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Program.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const programsGetGroupedRelationsInfiniteOptions = (
    options: Options<ProgramsGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        ProgramsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProgramsGetGroupedRelationsResponse>,
        QueryKey<Options<ProgramsGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<ProgramsGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProgramsGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await programsGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: programsGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Program.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const programsGetGroupedRelationsMutation = (
    options?: Partial<Options<ProgramsGetGroupedRelationsData>>,
): UseMutationOptions<
    ProgramsGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetAvatarsQueryKey = (options: Options<ProgramsGetAvatarsData>) =>
    createQueryKey('programsGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetAvatarsOptions = (options: Options<ProgramsGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Program",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetAvatarsMutation = (
    options?: Partial<Options<ProgramsGetAvatarsData>>,
): UseMutationOptions<
    ProgramsGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const programsGetRelationsAvatarsQueryKey = (
    options: Options<ProgramsGetRelationsAvatarsData>,
) => createQueryKey('programsGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetRelationsAvatarsOptions = (
    options: Options<ProgramsGetRelationsAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programsGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: programsGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const programsGetRelationsAvatarsMutation = (
    options?: Partial<Options<ProgramsGetRelationsAvatarsData>>,
): UseMutationOptions<
    ProgramsGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<ProgramsGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProgramsGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<ProgramsGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await programsGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetQueryKey = (options: Options<ProjectsGetData>) =>
    createQueryKey('projectsGet', options);

/**
 * Returns a list of Projects.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const projectsGetOptions = (options: Options<ProjectsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetQueryKey(options),
    });
};

export const projectsGetInfiniteQueryKey = (
    options: Options<ProjectsGetData>,
): QueryKey<Options<ProjectsGetData>> => createQueryKey('projectsGet', options, true);

/**
 * Returns a list of Projects.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const projectsGetInfiniteOptions = (options: Options<ProjectsGetData>) => {
    return infiniteQueryOptions<
        ProjectsGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProjectsGetResponse>,
        QueryKey<Options<ProjectsGetData>>,
        number | Pick<QueryKey<Options<ProjectsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProjectsGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await projectsGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: projectsGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Projects.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const projectsGetMutation = (
    options?: Partial<Options<ProjectsGetData>>,
): UseMutationOptions<ProjectsGetResponse, AxiosError<DefaultError>, Options<ProjectsGetData>> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetGroupedQueryKey = (options: Options<ProjectsGetGroupedData>) =>
    createQueryKey('projectsGetGrouped', options);

/**
 * Returns a grouped list of Projects.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const projectsGetGroupedOptions = (options: Options<ProjectsGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetGroupedQueryKey(options),
    });
};

export const projectsGetGroupedInfiniteQueryKey = (
    options: Options<ProjectsGetGroupedData>,
): QueryKey<Options<ProjectsGetGroupedData>> => createQueryKey('projectsGetGrouped', options, true);

/**
 * Returns a grouped list of Projects.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const projectsGetGroupedInfiniteOptions = (options: Options<ProjectsGetGroupedData>) => {
    return infiniteQueryOptions<
        ProjectsGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProjectsGetGroupedResponse>,
        QueryKey<Options<ProjectsGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<ProjectsGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProjectsGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await projectsGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: projectsGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Projects.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const projectsGetGroupedMutation = (
    options?: Partial<Options<ProjectsGetGroupedData>>,
): UseMutationOptions<
    ProjectsGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetByIdentifierQueryKey = (options: Options<ProjectsGetByIdentifierData>) =>
    createQueryKey('projectsGetByIdentifier', options);

/**
 * Returns a Project by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const projectsGetByIdentifierOptions = (options: Options<ProjectsGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Project by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const projectsGetByIdentifierMutation = (
    options?: Partial<Options<ProjectsGetByIdentifierData>>,
): UseMutationOptions<
    ProjectsGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetByIdsQueryKey = (options: Options<ProjectsGetByIdsData>) =>
    createQueryKey('projectsGetByIds', options);

/**
 * Returns a list of Projects by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const projectsGetByIdsOptions = (options: Options<ProjectsGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetByIdsQueryKey(options),
    });
};

export const projectsGetByIdsInfiniteQueryKey = (
    options: Options<ProjectsGetByIdsData>,
): QueryKey<Options<ProjectsGetByIdsData>> => createQueryKey('projectsGetByIds', options, true);

/**
 * Returns a list of Projects by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const projectsGetByIdsInfiniteOptions = (options: Options<ProjectsGetByIdsData>) => {
    return infiniteQueryOptions<
        ProjectsGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProjectsGetByIdsResponse>,
        QueryKey<Options<ProjectsGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<ProjectsGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProjectsGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await projectsGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: projectsGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Projects by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const projectsGetByIdsMutation = (
    options?: Partial<Options<ProjectsGetByIdsData>>,
): UseMutationOptions<
    ProjectsGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetCountQueryKey = (options: Options<ProjectsGetCountData>) =>
    createQueryKey('projectsGetCount', options);

/**
 * Returns the number of Projects.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetCountOptions = (options: Options<ProjectsGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Projects.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetCountMutation = (
    options?: Partial<Options<ProjectsGetCountData>>,
): UseMutationOptions<
    ProjectsGetCountResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetCountResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetRelationsQueryKey = (options: Options<ProjectsGetRelationsData>) =>
    createQueryKey('projectsGetRelations', options);

/**
 * Returns a list of items related to a Project.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const projectsGetRelationsOptions = (options: Options<ProjectsGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetRelationsQueryKey(options),
    });
};

export const projectsGetRelationsInfiniteQueryKey = (
    options: Options<ProjectsGetRelationsData>,
): QueryKey<Options<ProjectsGetRelationsData>> =>
    createQueryKey('projectsGetRelations', options, true);

/**
 * Returns a list of items related to a Project.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const projectsGetRelationsInfiniteOptions = (options: Options<ProjectsGetRelationsData>) => {
    return infiniteQueryOptions<
        ProjectsGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProjectsGetRelationsResponse>,
        QueryKey<Options<ProjectsGetRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<ProjectsGetRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProjectsGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await projectsGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: projectsGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Project.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const projectsGetRelationsMutation = (
    options?: Partial<Options<ProjectsGetRelationsData>>,
): UseMutationOptions<
    ProjectsGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetRelationsCountQueryKey = (
    options: Options<ProjectsGetRelationsCountData>,
) => createQueryKey('projectsGetRelationsCount', options);

/**
 * Returns the number of items related to a Project.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetRelationsCountOptions = (
    options: Options<ProjectsGetRelationsCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Project.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetRelationsCountMutation = (
    options?: Partial<Options<ProjectsGetRelationsCountData>>,
): UseMutationOptions<
    ProjectsGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetGroupedRelationsQueryKey = (
    options: Options<ProjectsGetGroupedRelationsData>,
) => createQueryKey('projectsGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Project.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const projectsGetGroupedRelationsOptions = (
    options: Options<ProjectsGetGroupedRelationsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetGroupedRelationsQueryKey(options),
    });
};

export const projectsGetGroupedRelationsInfiniteQueryKey = (
    options: Options<ProjectsGetGroupedRelationsData>,
): QueryKey<Options<ProjectsGetGroupedRelationsData>> =>
    createQueryKey('projectsGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Project.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const projectsGetGroupedRelationsInfiniteOptions = (
    options: Options<ProjectsGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        ProjectsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<ProjectsGetGroupedRelationsResponse>,
        QueryKey<Options<ProjectsGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<ProjectsGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<ProjectsGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await projectsGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: projectsGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Project.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const projectsGetGroupedRelationsMutation = (
    options?: Partial<Options<ProjectsGetGroupedRelationsData>>,
): UseMutationOptions<
    ProjectsGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetAvatarsQueryKey = (options: Options<ProjectsGetAvatarsData>) =>
    createQueryKey('projectsGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "ProjectManager",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetAvatarsOptions = (options: Options<ProjectsGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "ProjectManager",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Project",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetAvatarsMutation = (
    options?: Partial<Options<ProjectsGetAvatarsData>>,
): UseMutationOptions<
    ProjectsGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const projectsGetRelationsAvatarsQueryKey = (
    options: Options<ProjectsGetRelationsAvatarsData>,
) => createQueryKey('projectsGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetRelationsAvatarsOptions = (
    options: Options<ProjectsGetRelationsAvatarsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: projectsGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const projectsGetRelationsAvatarsMutation = (
    options?: Partial<Options<ProjectsGetRelationsAvatarsData>>,
): UseMutationOptions<
    ProjectsGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<ProjectsGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        ProjectsGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<ProjectsGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetQueryKey = (options: Options<TasksGetData>) =>
    createQueryKey('tasksGet', options);

/**
 * Returns a list of Tasks.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const tasksGetOptions = (options: Options<TasksGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetQueryKey(options),
    });
};

export const tasksGetInfiniteQueryKey = (
    options: Options<TasksGetData>,
): QueryKey<Options<TasksGetData>> => createQueryKey('tasksGet', options, true);

/**
 * Returns a list of Tasks.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const tasksGetInfiniteOptions = (options: Options<TasksGetData>) => {
    return infiniteQueryOptions<
        TasksGetResponse,
        AxiosError<DefaultError>,
        InfiniteData<TasksGetResponse>,
        QueryKey<Options<TasksGetData>>,
        number | Pick<QueryKey<Options<TasksGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<TasksGetData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await tasksGet({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: tasksGetInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Tasks.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const tasksGetMutation = (
    options?: Partial<Options<TasksGetData>>,
): UseMutationOptions<TasksGetResponse, AxiosError<DefaultError>, Options<TasksGetData>> => {
    const mutationOptions: UseMutationOptions<
        TasksGetResponse,
        AxiosError<DefaultError>,
        Options<TasksGetData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGet({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetGroupedQueryKey = (options: Options<TasksGetGroupedData>) =>
    createQueryKey('tasksGetGrouped', options);

/**
 * Returns a grouped list of Tasks.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const tasksGetGroupedOptions = (options: Options<TasksGetGroupedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetGrouped({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetGroupedQueryKey(options),
    });
};

export const tasksGetGroupedInfiniteQueryKey = (
    options: Options<TasksGetGroupedData>,
): QueryKey<Options<TasksGetGroupedData>> => createQueryKey('tasksGetGrouped', options, true);

/**
 * Returns a grouped list of Tasks.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const tasksGetGroupedInfiniteOptions = (options: Options<TasksGetGroupedData>) => {
    return infiniteQueryOptions<
        TasksGetGroupedResponse,
        AxiosError<DefaultError>,
        InfiniteData<TasksGetGroupedResponse>,
        QueryKey<Options<TasksGetGroupedData>>,
        | number
        | Pick<QueryKey<Options<TasksGetGroupedData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<TasksGetGroupedData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await tasksGetGrouped({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: tasksGetGroupedInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of Tasks.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Active"
 * }
 */
export const tasksGetGroupedMutation = (
    options?: Partial<Options<TasksGetGroupedData>>,
): UseMutationOptions<
    TasksGetGroupedResponse,
    AxiosError<DefaultError>,
    Options<TasksGetGroupedData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetGroupedResponse,
        AxiosError<DefaultError>,
        Options<TasksGetGroupedData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetGrouped({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetByIdentifierQueryKey = (options: Options<TasksGetByIdentifierData>) =>
    createQueryKey('tasksGetByIdentifier', options);

/**
 * Returns a Task by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const tasksGetByIdentifierOptions = (options: Options<TasksGetByIdentifierData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetByIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetByIdentifierQueryKey(options),
    });
};

/**
 * Returns a Task by its identifier.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "excludePermissions": true
 * }
 */
export const tasksGetByIdentifierMutation = (
    options?: Partial<Options<TasksGetByIdentifierData>>,
): UseMutationOptions<
    TasksGetByIdentifierResponse,
    AxiosError<DefaultError>,
    Options<TasksGetByIdentifierData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetByIdentifierResponse,
        AxiosError<DefaultError>,
        Options<TasksGetByIdentifierData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetByIdentifier({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetByIdsQueryKey = (options: Options<TasksGetByIdsData>) =>
    createQueryKey('tasksGetByIds', options);

/**
 * Returns a list of Tasks by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const tasksGetByIdsOptions = (options: Options<TasksGetByIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetByIdsQueryKey(options),
    });
};

export const tasksGetByIdsInfiniteQueryKey = (
    options: Options<TasksGetByIdsData>,
): QueryKey<Options<TasksGetByIdsData>> => createQueryKey('tasksGetByIds', options, true);

/**
 * Returns a list of Tasks by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const tasksGetByIdsInfiniteOptions = (options: Options<TasksGetByIdsData>) => {
    return infiniteQueryOptions<
        TasksGetByIdsResponse,
        AxiosError<DefaultError>,
        InfiniteData<TasksGetByIdsResponse>,
        QueryKey<Options<TasksGetByIdsData>>,
        | number
        | Pick<QueryKey<Options<TasksGetByIdsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<TasksGetByIdsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await tasksGetByIds({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: tasksGetByIdsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of Tasks by their identifiers.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "ids": ["11.222.333", "44.555.66"]
 * }
 */
export const tasksGetByIdsMutation = (
    options?: Partial<Options<TasksGetByIdsData>>,
): UseMutationOptions<
    TasksGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<TasksGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<TasksGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetCountQueryKey = (options: Options<TasksGetCountData>) =>
    createQueryKey('tasksGetCount', options);

/**
 * Returns the number of Tasks.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetCountOptions = (options: Options<TasksGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetCountQueryKey(options),
    });
};

/**
 * Returns the number of Tasks.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetCountMutation = (
    options?: Partial<Options<TasksGetCountData>>,
): UseMutationOptions<
    TasksGetCountResponse,
    AxiosError<DefaultError>,
    Options<TasksGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetCountResponse,
        AxiosError<DefaultError>,
        Options<TasksGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetRelationsQueryKey = (options: Options<TasksGetRelationsData>) =>
    createQueryKey('tasksGetRelations', options);

/**
 * Returns a list of items related to a Task.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const tasksGetRelationsOptions = (options: Options<TasksGetRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetRelationsQueryKey(options),
    });
};

export const tasksGetRelationsInfiniteQueryKey = (
    options: Options<TasksGetRelationsData>,
): QueryKey<Options<TasksGetRelationsData>> => createQueryKey('tasksGetRelations', options, true);

/**
 * Returns a list of items related to a Task.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const tasksGetRelationsInfiniteOptions = (options: Options<TasksGetRelationsData>) => {
    return infiniteQueryOptions<
        TasksGetRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<TasksGetRelationsResponse>,
        QueryKey<Options<TasksGetRelationsData>>,
        | number
        | Pick<QueryKey<Options<TasksGetRelationsData>>[0], 'body' | 'headers' | 'path' | 'query'>
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<TasksGetRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await tasksGetRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: tasksGetRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a list of items related to a Task.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true
 * }
 */
export const tasksGetRelationsMutation = (
    options?: Partial<Options<TasksGetRelationsData>>,
): UseMutationOptions<
    TasksGetRelationsResponse,
    AxiosError<DefaultError>,
    Options<TasksGetRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetRelationsResponse,
        AxiosError<DefaultError>,
        Options<TasksGetRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetRelationsCountQueryKey = (options: Options<TasksGetRelationsCountData>) =>
    createQueryKey('tasksGetRelationsCount', options);

/**
 * Returns the number of items related to a Task.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetRelationsCountOptions = (options: Options<TasksGetRelationsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetRelationsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetRelationsCountQueryKey(options),
    });
};

/**
 * Returns the number of items related to a Task.
 * Sample request:
 *
 * {
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetRelationsCountMutation = (
    options?: Partial<Options<TasksGetRelationsCountData>>,
): UseMutationOptions<
    TasksGetRelationsCountResponse,
    AxiosError<DefaultError>,
    Options<TasksGetRelationsCountData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetRelationsCountResponse,
        AxiosError<DefaultError>,
        Options<TasksGetRelationsCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetRelationsCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetGroupedRelationsQueryKey = (options: Options<TasksGetGroupedRelationsData>) =>
    createQueryKey('tasksGetGroupedRelations', options);

/**
 * Returns a grouped list of items related to a Task.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const tasksGetGroupedRelationsOptions = (options: Options<TasksGetGroupedRelationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetGroupedRelations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetGroupedRelationsQueryKey(options),
    });
};

export const tasksGetGroupedRelationsInfiniteQueryKey = (
    options: Options<TasksGetGroupedRelationsData>,
): QueryKey<Options<TasksGetGroupedRelationsData>> =>
    createQueryKey('tasksGetGroupedRelations', options, true);

/**
 * Returns a grouped list of items related to a Task.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const tasksGetGroupedRelationsInfiniteOptions = (
    options: Options<TasksGetGroupedRelationsData>,
) => {
    return infiniteQueryOptions<
        TasksGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        InfiniteData<TasksGetGroupedRelationsResponse>,
        QueryKey<Options<TasksGetGroupedRelationsData>>,
        | number
        | Pick<
              QueryKey<Options<TasksGetGroupedRelationsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<TasksGetGroupedRelationsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await tasksGetGroupedRelations({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: tasksGetGroupedRelationsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns a grouped list of items related to a Task.
 * Sample request:
 *
 * {
 * "fields": [
 * "name",
 * "createdOn",
 * "state"
 * ],
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Risk",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ],
 * "offset": 0,
 * "limit": 25,
 * "sortBy": "name",
 * "sortStrategy": "Asc",
 * "excludePermissions": true,
 * "groupBy": "state",
 * "groupName": "Submitted"
 * }
 */
export const tasksGetGroupedRelationsMutation = (
    options?: Partial<Options<TasksGetGroupedRelationsData>>,
): UseMutationOptions<
    TasksGetGroupedRelationsResponse,
    AxiosError<DefaultError>,
    Options<TasksGetGroupedRelationsData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetGroupedRelationsResponse,
        AxiosError<DefaultError>,
        Options<TasksGetGroupedRelationsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetGroupedRelations({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetAvatarsQueryKey = (options: Options<TasksGetAvatarsData>) =>
    createQueryKey('tasksGetAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetAvatarsOptions = (options: Options<TasksGetAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "fieldName": "Owner",
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "Task",
 * "fieldName": "percentCompleted"
 * },
 * "operator": "Between",
 * "filterValueType": "Numeric",
 * "values": [
 * {
 * "value": 10
 * },
 * {
 * "value": 20
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetAvatarsMutation = (
    options?: Partial<Options<TasksGetAvatarsData>>,
): UseMutationOptions<
    TasksGetAvatarsResponse,
    AxiosError<DefaultError>,
    Options<TasksGetAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetAvatarsResponse,
        AxiosError<DefaultError>,
        Options<TasksGetAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const tasksGetRelationsAvatarsQueryKey = (options: Options<TasksGetRelationsAvatarsData>) =>
    createQueryKey('tasksGetRelationsAvatars', options);

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetRelationsAvatarsOptions = (options: Options<TasksGetRelationsAvatarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tasksGetRelationsAvatars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: tasksGetRelationsAvatarsQueryKey(options),
    });
};

/**
 * Returns a list of Unique Users and groups.
 * Sample request:
 *
 * {
 * "relation": {
 * "name": "ResourcesAndPlaceholders",
 * "filteredEntityType": "User"
 * },
 * "dataFilters": [
 * {
 * "field": {
 * "entityType": "workitem",
 * "fieldName": "name"
 * },
 * "operator": "Contains",
 * "filterValueType": "Text",
 * "values": [
 * {
 * "value": "111111"
 * }
 * ]
 * }
 * ]
 * }
 */
export const tasksGetRelationsAvatarsMutation = (
    options?: Partial<Options<TasksGetRelationsAvatarsData>>,
): UseMutationOptions<
    TasksGetRelationsAvatarsResponse,
    AxiosError<DefaultError>,
    Options<TasksGetRelationsAvatarsData>
> => {
    const mutationOptions: UseMutationOptions<
        TasksGetRelationsAvatarsResponse,
        AxiosError<DefaultError>,
        Options<TasksGetRelationsAvatarsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await tasksGetRelationsAvatars({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const dataWarehouseEntityGetCountQueryKey = (
    options: Options<DataWarehouseEntityGetCountData>,
) => createQueryKey('dataWarehouseEntityGetCount', options);

export const dataWarehouseEntityGetCountOptions = (
    options: Options<DataWarehouseEntityGetCountData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await dataWarehouseEntityGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: dataWarehouseEntityGetCountQueryKey(options),
    });
};

export const dataWarehouseEntityGetCountMutation = (
    options?: Partial<Options<DataWarehouseEntityGetCountData>>,
): UseMutationOptions<
    DataWarehouseEntityGetCountResponse,
    AxiosError<DefaultError>,
    Options<DataWarehouseEntityGetCountData>
> => {
    const mutationOptions: UseMutationOptions<
        DataWarehouseEntityGetCountResponse,
        AxiosError<DefaultError>,
        Options<DataWarehouseEntityGetCountData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await dataWarehouseEntityGetCount({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const dataWarehouseEntityGetByIdsQueryKey = (
    options: Options<DataWarehouseEntityGetByIdsData>,
) => createQueryKey('dataWarehouseEntityGetByIds', options);

export const dataWarehouseEntityGetByIdsOptions = (
    options: Options<DataWarehouseEntityGetByIdsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await dataWarehouseEntityGetByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: dataWarehouseEntityGetByIdsQueryKey(options),
    });
};

export const dataWarehouseEntityGetByIdsMutation = (
    options?: Partial<Options<DataWarehouseEntityGetByIdsData>>,
): UseMutationOptions<
    DataWarehouseEntityGetByIdsResponse,
    AxiosError<DefaultError>,
    Options<DataWarehouseEntityGetByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        DataWarehouseEntityGetByIdsResponse,
        AxiosError<DefaultError>,
        Options<DataWarehouseEntityGetByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await dataWarehouseEntityGetByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const dataWarehouseEntityGetIdsQueryKey = (
    options: Options<DataWarehouseEntityGetIdsData>,
) => createQueryKey('dataWarehouseEntityGetIds', options);

export const dataWarehouseEntityGetIdsOptions = (
    options: Options<DataWarehouseEntityGetIdsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await dataWarehouseEntityGetIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: dataWarehouseEntityGetIdsQueryKey(options),
    });
};

export const dataWarehouseEntityGetIdsMutation = (
    options?: Partial<Options<DataWarehouseEntityGetIdsData>>,
): UseMutationOptions<
    DataWarehouseEntityGetIdsResponse,
    AxiosError<DefaultError>,
    Options<DataWarehouseEntityGetIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        DataWarehouseEntityGetIdsResponse,
        AxiosError<DefaultError>,
        Options<DataWarehouseEntityGetIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await dataWarehouseEntityGetIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const configurationGetConfigurationQueryKey = (
    options: Options<ConfigurationGetConfigurationData>,
) => createQueryKey('configurationGetConfiguration', options);

export const configurationGetConfigurationOptions = (
    options: Options<ConfigurationGetConfigurationData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await configurationGetConfiguration({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: configurationGetConfigurationQueryKey(options),
    });
};

export const configurationGetConfigurationMutation = (
    options?: Partial<Options<ConfigurationGetConfigurationData>>,
): UseMutationOptions<
    ConfigurationGetConfigurationResponse,
    AxiosError<DefaultError>,
    Options<ConfigurationGetConfigurationData>
> => {
    const mutationOptions: UseMutationOptions<
        ConfigurationGetConfigurationResponse,
        AxiosError<DefaultError>,
        Options<ConfigurationGetConfigurationData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await configurationGetConfiguration({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const configurationUpdateConfigurationMutation = (
    options?: Partial<Options<ConfigurationUpdateConfigurationData>>,
): UseMutationOptions<
    unknown,
    AxiosError<DefaultError>,
    Options<ConfigurationUpdateConfigurationData>
> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DefaultError>,
        Options<ConfigurationUpdateConfigurationData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await configurationUpdateConfiguration({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const storageConnectionsTestAzureBlobConnectionQueryKey = (
    options: Options<StorageConnectionsTestAzureBlobConnectionData>,
) => createQueryKey('storageConnectionsTestAzureBlobConnection', options);

export const storageConnectionsTestAzureBlobConnectionOptions = (
    options: Options<StorageConnectionsTestAzureBlobConnectionData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await storageConnectionsTestAzureBlobConnection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: storageConnectionsTestAzureBlobConnectionQueryKey(options),
    });
};

export const storageConnectionsTestAzureBlobConnectionMutation = (
    options?: Partial<Options<StorageConnectionsTestAzureBlobConnectionData>>,
): UseMutationOptions<
    StorageConnectionsTestAzureBlobConnectionResponse,
    AxiosError<DefaultError>,
    Options<StorageConnectionsTestAzureBlobConnectionData>
> => {
    const mutationOptions: UseMutationOptions<
        StorageConnectionsTestAzureBlobConnectionResponse,
        AxiosError<DefaultError>,
        Options<StorageConnectionsTestAzureBlobConnectionData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await storageConnectionsTestAzureBlobConnection({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const triggerExportTriggerExportQueryKey = (
    options?: Options<TriggerExportTriggerExportData>,
) => createQueryKey('triggerExportTriggerExport', options);

export const triggerExportTriggerExportOptions = (
    options?: Options<TriggerExportTriggerExportData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await triggerExportTriggerExport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: triggerExportTriggerExportQueryKey(options),
    });
};

export const triggerExportTriggerExportMutation = (
    options?: Partial<Options<TriggerExportTriggerExportData>>,
): UseMutationOptions<
    unknown,
    AxiosError<DefaultError>,
    Options<TriggerExportTriggerExportData>
> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DefaultError>,
        Options<TriggerExportTriggerExportData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await triggerExportTriggerExport({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const planviewAdminVerifyConnectQueryKey = (
    options: Options<PlanviewAdminVerifyConnectData>,
) => createQueryKey('planviewAdminVerifyConnect', options);

export const planviewAdminVerifyConnectOptions = (
    options: Options<PlanviewAdminVerifyConnectData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await planviewAdminVerifyConnect({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: planviewAdminVerifyConnectQueryKey(options),
    });
};

export const planviewAdminVerifyConnectMutation = (
    options?: Partial<Options<PlanviewAdminVerifyConnectData>>,
): UseMutationOptions<
    unknown,
    AxiosError<DefaultError>,
    Options<PlanviewAdminVerifyConnectData>
> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DefaultError>,
        Options<PlanviewAdminVerifyConnectData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await planviewAdminVerifyConnect({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const planviewAdminGetUsersQueryKey = (options?: Options<PlanviewAdminGetUsersData>) =>
    createQueryKey('planviewAdminGetUsers', options);

export const planviewAdminGetUsersOptions = (options?: Options<PlanviewAdminGetUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await planviewAdminGetUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: planviewAdminGetUsersQueryKey(options),
    });
};

export const planviewAdminGetQueryKey = (options?: Options<PlanviewAdminGetData>) =>
    createQueryKey('planviewAdminGet', options);

export const planviewAdminGetOptions = (options?: Options<PlanviewAdminGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await planviewAdminGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: planviewAdminGetQueryKey(options),
    });
};

export const planviewAdminRegisterQueryKey = (options: Options<PlanviewAdminRegisterData>) =>
    createQueryKey('planviewAdminRegister', options);

export const planviewAdminRegisterOptions = (options: Options<PlanviewAdminRegisterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await planviewAdminRegister({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: planviewAdminRegisterQueryKey(options),
    });
};

export const planviewAdminRegisterMutation = (
    options?: Partial<Options<PlanviewAdminRegisterData>>,
): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<PlanviewAdminRegisterData>> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DefaultError>,
        Options<PlanviewAdminRegisterData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await planviewAdminRegister({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const planviewTokenServiceGetPtsTokenForCoPilotQueryKey = (
    options?: Options<PlanviewTokenServiceGetPtsTokenForCoPilotData>,
) => createQueryKey('planviewTokenServiceGetPtsTokenForCoPilot', options);

export const planviewTokenServiceGetPtsTokenForCoPilotOptions = (
    options?: Options<PlanviewTokenServiceGetPtsTokenForCoPilotData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await planviewTokenServiceGetPtsTokenForCoPilot({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: planviewTokenServiceGetPtsTokenForCoPilotQueryKey(options),
    });
};

export const planviewTokenServiceGetPtsTokenInternalQueryKey = (
    options?: Options<PlanviewTokenServiceGetPtsTokenInternalData>,
) => createQueryKey('planviewTokenServiceGetPtsTokenInternal', options);

export const planviewTokenServiceGetPtsTokenInternalOptions = (
    options?: Options<PlanviewTokenServiceGetPtsTokenInternalData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await planviewTokenServiceGetPtsTokenInternal({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: planviewTokenServiceGetPtsTokenInternalQueryKey(options),
    });
};

export const sentimentAnalysisServiceCalculateSentimentQueryKey = (
    options: Options<SentimentAnalysisServiceCalculateSentimentData>,
) => createQueryKey('sentimentAnalysisServiceCalculateSentiment', options);

export const sentimentAnalysisServiceCalculateSentimentOptions = (
    options: Options<SentimentAnalysisServiceCalculateSentimentData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sentimentAnalysisServiceCalculateSentiment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: sentimentAnalysisServiceCalculateSentimentQueryKey(options),
    });
};

export const sentimentAnalysisServiceCalculateSentimentMutation = (
    options?: Partial<Options<SentimentAnalysisServiceCalculateSentimentData>>,
): UseMutationOptions<
    SentimentAnalysisServiceCalculateSentimentResponse,
    AxiosError<DefaultError>,
    Options<SentimentAnalysisServiceCalculateSentimentData>
> => {
    const mutationOptions: UseMutationOptions<
        SentimentAnalysisServiceCalculateSentimentResponse,
        AxiosError<DefaultError>,
        Options<SentimentAnalysisServiceCalculateSentimentData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await sentimentAnalysisServiceCalculateSentiment({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const whiteboardPtsTokenForWhiteboardQueryKey = (
    options: Options<WhiteboardPtsTokenForWhiteboardData>,
) => createQueryKey('whiteboardPtsTokenForWhiteboard', options);

export const whiteboardPtsTokenForWhiteboardOptions = (
    options: Options<WhiteboardPtsTokenForWhiteboardData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await whiteboardPtsTokenForWhiteboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: whiteboardPtsTokenForWhiteboardQueryKey(options),
    });
};

export const workloadGetWorkloadResourcesQueryKey = (
    options: Options<WorkloadGetWorkloadResourcesData>,
) => createQueryKey('workloadGetWorkloadResources', options);

/**
 * Returns the Resources with planning data.
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:00:00.000Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "sourceEntity": {
 * "entityType": "ResourceEntity",
 * "entityKeys": [
 * {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.2.1"
 * }
 * ]
 * },
 * "offset": 0,
 * "limit": 25
 * }
 */
export const workloadGetWorkloadResourcesOptions = (
    options: Options<WorkloadGetWorkloadResourcesData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await workloadGetWorkloadResources({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: workloadGetWorkloadResourcesQueryKey(options),
    });
};

export const workloadGetWorkloadResourcesInfiniteQueryKey = (
    options: Options<WorkloadGetWorkloadResourcesData>,
): QueryKey<Options<WorkloadGetWorkloadResourcesData>> =>
    createQueryKey('workloadGetWorkloadResources', options, true);

/**
 * Returns the Resources with planning data.
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:00:00.000Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "sourceEntity": {
 * "entityType": "ResourceEntity",
 * "entityKeys": [
 * {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.2.1"
 * }
 * ]
 * },
 * "offset": 0,
 * "limit": 25
 * }
 */
export const workloadGetWorkloadResourcesInfiniteOptions = (
    options: Options<WorkloadGetWorkloadResourcesData>,
) => {
    return infiniteQueryOptions<
        WorkloadGetWorkloadResourcesResponse,
        AxiosError<DefaultError>,
        InfiniteData<WorkloadGetWorkloadResourcesResponse>,
        QueryKey<Options<WorkloadGetWorkloadResourcesData>>,
        | number
        | Pick<
              QueryKey<Options<WorkloadGetWorkloadResourcesData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<WorkloadGetWorkloadResourcesData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await workloadGetWorkloadResources({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: workloadGetWorkloadResourcesInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns the Resources with planning data.
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:00:00.000Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "sourceEntity": {
 * "entityType": "ResourceEntity",
 * "entityKeys": [
 * {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.2.1"
 * }
 * ]
 * },
 * "offset": 0,
 * "limit": 25
 * }
 */
export const workloadGetWorkloadResourcesMutation = (
    options?: Partial<Options<WorkloadGetWorkloadResourcesData>>,
): UseMutationOptions<
    WorkloadGetWorkloadResourcesResponse,
    AxiosError<DefaultError>,
    Options<WorkloadGetWorkloadResourcesData>
> => {
    const mutationOptions: UseMutationOptions<
        WorkloadGetWorkloadResourcesResponse,
        AxiosError<DefaultError>,
        Options<WorkloadGetWorkloadResourcesData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await workloadGetWorkloadResources({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const workloadGetWorkloadProjectsQueryKey = (
    options: Options<WorkloadGetWorkloadProjectsData>,
) => createQueryKey('workloadGetWorkloadProjects', options);

/**
 * Returns the Projects for a particular resource with planning data
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:57:02.635Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "resourceEntityKey": {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * "offset": 0,
 * "limit": 25
 * }
 */
export const workloadGetWorkloadProjectsOptions = (
    options: Options<WorkloadGetWorkloadProjectsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await workloadGetWorkloadProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: workloadGetWorkloadProjectsQueryKey(options),
    });
};

export const workloadGetWorkloadProjectsInfiniteQueryKey = (
    options: Options<WorkloadGetWorkloadProjectsData>,
): QueryKey<Options<WorkloadGetWorkloadProjectsData>> =>
    createQueryKey('workloadGetWorkloadProjects', options, true);

/**
 * Returns the Projects for a particular resource with planning data
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:57:02.635Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "resourceEntityKey": {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * "offset": 0,
 * "limit": 25
 * }
 */
export const workloadGetWorkloadProjectsInfiniteOptions = (
    options: Options<WorkloadGetWorkloadProjectsData>,
) => {
    return infiniteQueryOptions<
        WorkloadGetWorkloadProjectsResponse,
        AxiosError<DefaultError>,
        InfiniteData<WorkloadGetWorkloadProjectsResponse>,
        QueryKey<Options<WorkloadGetWorkloadProjectsData>>,
        | number
        | Pick<
              QueryKey<Options<WorkloadGetWorkloadProjectsData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<WorkloadGetWorkloadProjectsData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await workloadGetWorkloadProjects({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: workloadGetWorkloadProjectsInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns the Projects for a particular resource with planning data
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:57:02.635Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "resourceEntityKey": {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * "offset": 0,
 * "limit": 25
 * }
 */
export const workloadGetWorkloadProjectsMutation = (
    options?: Partial<Options<WorkloadGetWorkloadProjectsData>>,
): UseMutationOptions<
    WorkloadGetWorkloadProjectsResponse,
    AxiosError<DefaultError>,
    Options<WorkloadGetWorkloadProjectsData>
> => {
    const mutationOptions: UseMutationOptions<
        WorkloadGetWorkloadProjectsResponse,
        AxiosError<DefaultError>,
        Options<WorkloadGetWorkloadProjectsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await workloadGetWorkloadProjects({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const workloadGetWorkloadTasksQueryKey = (options: Options<WorkloadGetWorkloadTasksData>) =>
    createQueryKey('workloadGetWorkloadTasks', options);

/**
 * Returns the Tasks for a particular project with planning data
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "businessUnitId": 0,
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:57:02.635Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "resourceEntityKey": {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * "offset": 0,
 * "limit": 25,
 * }
 */
export const workloadGetWorkloadTasksOptions = (options: Options<WorkloadGetWorkloadTasksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await workloadGetWorkloadTasks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: workloadGetWorkloadTasksQueryKey(options),
    });
};

export const workloadGetWorkloadTasksInfiniteQueryKey = (
    options: Options<WorkloadGetWorkloadTasksData>,
): QueryKey<Options<WorkloadGetWorkloadTasksData>> =>
    createQueryKey('workloadGetWorkloadTasks', options, true);

/**
 * Returns the Tasks for a particular project with planning data
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "businessUnitId": 0,
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:57:02.635Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "resourceEntityKey": {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * "offset": 0,
 * "limit": 25,
 * }
 */
export const workloadGetWorkloadTasksInfiniteOptions = (
    options: Options<WorkloadGetWorkloadTasksData>,
) => {
    return infiniteQueryOptions<
        WorkloadGetWorkloadTasksResponse,
        AxiosError<DefaultError>,
        InfiniteData<WorkloadGetWorkloadTasksResponse>,
        QueryKey<Options<WorkloadGetWorkloadTasksData>>,
        | number
        | Pick<
              QueryKey<Options<WorkloadGetWorkloadTasksData>>[0],
              'body' | 'headers' | 'path' | 'query'
          >
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<WorkloadGetWorkloadTasksData>>[0],
                    'body' | 'headers' | 'path' | 'query'
                > =
                    typeof pageParam === 'object'
                        ? pageParam
                        : {
                              body: {
                                  offset: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await workloadGetWorkloadTasks({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: workloadGetWorkloadTasksInfiniteQueryKey(options),
        },
    );
};

/**
 * Returns the Tasks for a particular project with planning data
 * Sample request:
 *
 * {
 * "workloadSettings": {
 * "aggregationTypes": "None",
 * "businessUnitId": 0,
 * "loadBaseType": "ProjectAssignment",
 * "measureType": "Hours",
 * "slicePeriodType": "Day",
 * "slicesAmount": 5,
 * "sliceStartDate": "2024-04-16T10:57:02.635Z",
 * "workloadRootEntityType": "Resources"
 * },
 * "resourceEntityKey": {
 * "businessUnitId": "2.2.2",
 * "entityId": "1.1.1"
 * },
 * "offset": 0,
 * "limit": 25,
 * }
 */
export const workloadGetWorkloadTasksMutation = (
    options?: Partial<Options<WorkloadGetWorkloadTasksData>>,
): UseMutationOptions<
    WorkloadGetWorkloadTasksResponse,
    AxiosError<DefaultError>,
    Options<WorkloadGetWorkloadTasksData>
> => {
    const mutationOptions: UseMutationOptions<
        WorkloadGetWorkloadTasksResponse,
        AxiosError<DefaultError>,
        Options<WorkloadGetWorkloadTasksData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await workloadGetWorkloadTasks({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetReportableWorkItemsPerUserQueryKey = (
    options: Options<PublicisGetReportableWorkItemsPerUserData>,
) => createQueryKey('publicisGetReportableWorkItemsPerUser', options);

export const publicisGetReportableWorkItemsPerUserOptions = (
    options: Options<PublicisGetReportableWorkItemsPerUserData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetReportableWorkItemsPerUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetReportableWorkItemsPerUserQueryKey(options),
    });
};

export const publicisGetReportableWorkItemsPerUserMutation = (
    options?: Partial<Options<PublicisGetReportableWorkItemsPerUserData>>,
): UseMutationOptions<
    PublicisGetReportableWorkItemsPerUserResponse,
    AxiosError<DefaultError>,
    Options<PublicisGetReportableWorkItemsPerUserData>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetReportableWorkItemsPerUserResponse,
        AxiosError<DefaultError>,
        Options<PublicisGetReportableWorkItemsPerUserData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetReportableWorkItemsPerUser({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetReportableTasksByIdsQueryKey = (
    options: Options<PublicisGetReportableTasksByIdsData>,
) => createQueryKey('publicisGetReportableTasksByIds', options);

export const publicisGetReportableTasksByIdsOptions = (
    options: Options<PublicisGetReportableTasksByIdsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetReportableTasksByIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetReportableTasksByIdsQueryKey(options),
    });
};

export const publicisGetReportableTasksByIdsMutation = (
    options?: Partial<Options<PublicisGetReportableTasksByIdsData>>,
): UseMutationOptions<
    PublicisGetReportableTasksByIdsResponse,
    AxiosError<DefaultError>,
    Options<PublicisGetReportableTasksByIdsData>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetReportableTasksByIdsResponse,
        AxiosError<DefaultError>,
        Options<PublicisGetReportableTasksByIdsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetReportableTasksByIds({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetReportableTasksByIds2QueryKey = (
    options: Options<PublicisGetReportableTasksByIds2Data>,
) => createQueryKey('publicisGetReportableTasksByIds2', options);

export const publicisGetReportableTasksByIds2Options = (
    options: Options<PublicisGetReportableTasksByIds2Data>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetReportableTasksByIds2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetReportableTasksByIds2QueryKey(options),
    });
};

export const publicisGetReportableTasksByIds2Mutation = (
    options?: Partial<Options<PublicisGetReportableTasksByIds2Data>>,
): UseMutationOptions<
    PublicisGetReportableTasksByIds2Response,
    AxiosError<DefaultError>,
    Options<PublicisGetReportableTasksByIds2Data>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetReportableTasksByIds2Response,
        AxiosError<DefaultError>,
        Options<PublicisGetReportableTasksByIds2Data>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetReportableTasksByIds2({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetAssignmentsPerUsersQueryKey = (
    options: Options<PublicisGetAssignmentsPerUsersData>,
) => createQueryKey('publicisGetAssignmentsPerUsers', options);

export const publicisGetAssignmentsPerUsersOptions = (
    options: Options<PublicisGetAssignmentsPerUsersData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetAssignmentsPerUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetAssignmentsPerUsersQueryKey(options),
    });
};

export const publicisGetAssignmentsPerUsersMutation = (
    options?: Partial<Options<PublicisGetAssignmentsPerUsersData>>,
): UseMutationOptions<
    PublicisGetAssignmentsPerUsersResponse,
    AxiosError<DefaultError>,
    Options<PublicisGetAssignmentsPerUsersData>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetAssignmentsPerUsersResponse,
        AxiosError<DefaultError>,
        Options<PublicisGetAssignmentsPerUsersData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetAssignmentsPerUsers({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetUsersWorkingHoursQueryKey = (
    options: Options<PublicisGetUsersWorkingHoursData>,
) => createQueryKey('publicisGetUsersWorkingHours', options);

export const publicisGetUsersWorkingHoursOptions = (
    options: Options<PublicisGetUsersWorkingHoursData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetUsersWorkingHours({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetUsersWorkingHoursQueryKey(options),
    });
};

export const publicisGetUsersWorkingHoursMutation = (
    options?: Partial<Options<PublicisGetUsersWorkingHoursData>>,
): UseMutationOptions<
    PublicisGetUsersWorkingHoursResponse,
    AxiosError<DefaultError>,
    Options<PublicisGetUsersWorkingHoursData>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetUsersWorkingHoursResponse,
        AxiosError<DefaultError>,
        Options<PublicisGetUsersWorkingHoursData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetUsersWorkingHours({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetGroupMembershipLinksQueryKey = (
    options: Options<PublicisGetGroupMembershipLinksData>,
) => createQueryKey('publicisGetGroupMembershipLinks', options);

export const publicisGetGroupMembershipLinksOptions = (
    options: Options<PublicisGetGroupMembershipLinksData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetGroupMembershipLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetGroupMembershipLinksQueryKey(options),
    });
};

export const publicisGetGroupMembershipLinksMutation = (
    options?: Partial<Options<PublicisGetGroupMembershipLinksData>>,
): UseMutationOptions<
    PublicisGetGroupMembershipLinksResponse,
    AxiosError<DefaultError>,
    Options<PublicisGetGroupMembershipLinksData>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetGroupMembershipLinksResponse,
        AxiosError<DefaultError>,
        Options<PublicisGetGroupMembershipLinksData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetGroupMembershipLinks({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const publicisGetResourceProjectsQueryKey = (
    options: Options<PublicisGetResourceProjectsData>,
) => createQueryKey('publicisGetResourceProjects', options);

export const publicisGetResourceProjectsOptions = (
    options: Options<PublicisGetResourceProjectsData>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publicisGetResourceProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: publicisGetResourceProjectsQueryKey(options),
    });
};

export const publicisGetResourceProjectsMutation = (
    options?: Partial<Options<PublicisGetResourceProjectsData>>,
): UseMutationOptions<
    PublicisGetResourceProjectsResponse,
    AxiosError<DefaultError>,
    Options<PublicisGetResourceProjectsData>
> => {
    const mutationOptions: UseMutationOptions<
        PublicisGetResourceProjectsResponse,
        AxiosError<DefaultError>,
        Options<PublicisGetResourceProjectsData>
    > = {
        mutationFn: async (localOptions) => {
            const { data } = await publicisGetResourceProjects({
                ...options,
                ...localOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};
